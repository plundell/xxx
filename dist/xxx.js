/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./build.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./build.js":
/*!******************!*\
  !*** ./build.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";'use strict';\n/*\n* @module xxx-framework\n* @author plundell\n* @license Apache-2.0\n* @depends libbetter\n* @depends smarties\n* @exports function   This framework exports an \"exporter function\" which should be called with the \n*                     dependencies to get the \"real exported contents\". It also creates a getter on\n*                     window.xxx which runs said exporter if the dependencies are also set on the window\n*/\n\n\n(function loadXXX(){\n\tif(!window)\n\t\tthrow new Error(\"ESCOPE. This script should have access to the 'window' global.\");\n\n\tconsole.log('Loading xxx-framework...');\n\n\t//Load the \"exporter function\". Mansplain: using an exporter implies no external dependencies need\n\t//to be require()'d from any internal script, which gives more control as to when and how these \n\t//dependencies are loaded, which in turn allows devs to supply other/altered/experimental versions.\n\tconst exporter=__webpack_require__(/*! ./src/xxx.proto.js */ \"./src/xxx.proto.js\");\n\n\t//Create a getter on the window which runs the exporter as soon as all dependencies are\n\t//available OR throws a clear error if we try to access it too early\n\tObject.defineProperty(window,'xxx',{enumerable:true, configurable:true\n\t\t,get:()=>{\n\t\t\tif(window.Smarties && window.BetterLog && window.BetterEvents && window.BetterUtil){ \n\t\t\t\treturn window.xxx=exporter(window);\n\t\t\t}else{\n\t\t\t\tthrow new Error(\"E_DEPENDENCY. The xxx-framework could not be initialized because it's dependencies \"\n\t\t\t\t\t+\"have not been set on the global scope\");\n\t\t\t}\n\t\t}\n\n\t\t//This setter allows^ the whole thing to easily be undone/overwritten\n\t\t,set:(val)=>{\n\t\t\tObject.defineProperty(window,'xxx',{value:val,enumerable:true,writable:true,configurable:true}); \n\t\t\treturn val;\n\t\t} \n\t})\n}())\n   \n\n\n\n//# sourceURL=webpack:///./build.js?");

/***/ }),

/***/ "./src/xxx-bind.class.js":
/*!*******************************!*\
  !*** ./src/xxx-bind.class.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("//simpleSourceMap=/my_modules/xxx/xxx-bind.class.js\n//simpleSourceMap2=/lib/xxx/xxx-bind.class.js\n\n/*\n* @component Binder\n* @part-of xxx-framework\n* @description This component provides two-way databinding to the DOM. \n* @author plundell\n* @license Apache-2.0\n* @note: This component is required by ./xxx.proto.js, you should not need to access it directly.\n* @depends libbetter\n* @depends ./xxx.proto.js\n* @depends smarties.Object\n* @exports {function} Call this function with the dependencies to get the Binder constructor\n*\n* Details:\n*\t- <Binder> objects extend <SmartObject>, ie. 1 binder per 1 smarty. Alternatively the binder can create\n*\t  an empty smarty and replicate its events.\n*\t- Outputting to the DOM is done by listening to events on the underlying smarty\n*\t- Inputting from the DOM is done by listening to 'input' events on <body> (ie. you can affect how/when\n*\t  the binder receives input by intercepting these events before they reach <body>, which is exactly\n*\t  what Binder.throttle() does). \n*/\nmodule.exports=function exportBinder(dep,proto){\n\n\tconst bu=dep.BetterUtil;\n\n\tconst INSTRUCTIONS=\"xxxBindInstructions\"\n\tconst BINDER=\"xxxBinder\"\n\tconst V_INST=\"xxxBind_valInst\"\n\tconst KEY=\"xxxBind_key\"\n\n\n\t/*\n\t* @constructor Binder\n\t*\n\t* @param string targetClass \tA HTML class that identifies all elements connected to this binder\n\t* @opt object options  \t\t\tGets assigned over Binder.defaultOptions and smarties.Object.defaultOptions\n\t* @opt object data \t\t\t\tData to set on the object right away. \n\t*\t^NOTE: This will assign over options.defaultValues\n\t* \t^NOTE: This triggers setup(), as opposed to passing options.defaultValues\n\t*\n\t* @emit 'input' (<Event>)\n\t* @emit Everything emitted by <SmartObject>\n\t*\n\t* @extends <SmartObject>\n\t*/\n\tfunction Binder(targetClass, options=null,data=null) {\n\n\t\t//Register this instance on Binder._instances\n\t\tproto.addInstance.call(this,targetClass);\n\n\t\toptions=options||{};\n\t\t//Make sure we log as the binder class\n\t\toptions.name=targetClass;\n\n\t\t\n\t\t//Are we upgrading an existing <SmartObject>... (see upgradeSmarty())\n\t\tif(this===data){\n\t\t\tthis._log.info(\"Turning this smarty into a Binder\");\n\t\t\tthis.__proto__=Binder.prototype;\n\n\t\t\t//Only options meant for Binder is allowed, the rest will be whatever the smarty is already using\n\t\t\toptions=bu.subObj(options,['scrapeForData','ignoreTimeout','name'],'excludeMissing');\n\t\t\tObject.assign(this._private.options,options);\n\n\t\t\t//We want to change the logname, either to something passed in^ or at least to \n\t\t\t//reflect that this is now a binder\n\t\t\tthis._log.changeName(options.name);\n\n\t\t\t//Any existing data will be propogated to the DOM after some more setup below.\n\n\n\t\t//...or are we creating a new <Binder> from scratch?\n\t\t}else{\n\t\t\t//If $data was passed in seperately, set it as defaultValues\n\t\t\tif(data && typeof data=='object'){\n\t\t\t\t\n\t\t\t\t//If data was a smarty we listen to events on it and extend to this Binder. That\n\t\t\t\t//way we get a one-way data connection so the same smarty can be used to seed \n\t\t\t\t//multiple Binders, and then additional values can be set on each binder without \n\t\t\t\t//affecting the shared smarty\n\t\t\t\tif(data.isSmart=='SmartObject'){\n\t\t\t\t\tthis.replicateFrom(data);\n\t\t\t\t\tdata=data.stupify();\n\t\t\t\t}\n\n\t\t\t\t//Any seperate data passed in is combined with options.defaultValues because \n\t\t\t\t//they're both together the default values of this Binder\n\t\t\t\toptions.defaultValues=Object.assign({},options.defaultValues,data);\n\t\t\t}\n\n\t\t\t//Extend the <SmartObject> class. If any data/defaultValues where passed in then they'll \n\t\t\t//emit events as the smarty calls .reset() as part of it's setup. The problem is we're \n\t\t\t//not listening for that yet, so we we manually propogate below.\n\t\t\tdep.Smarties.Object.call(this,Object.assign({},Binder._defaultOptions,options)); \n\t\t\t\t//^Sets up this._log, this._private and BetterEvents inheritence. \n\t\t}\n\t\t//NOTE: in both cases above (upgrade/new) we have yet to propogate data to the DOM\n\n\t\t//Define the classes that identify inputs and outputs\n\t\tthis._private.targetClass=targetClass  \n\t\t\n\t\n\t\t//Create this._private.actions and register the basic actions. NOTE: this.registerActionHandler is\n\t\t//added to our prototype below via proto.prototype\n\t\tproto.setupActions.call(this);\n\n\n\t\t//Listen to events emitted by self, and output data from them\n\t\tthis.on('event',dataEventCallback.bind(this));\n\n\n\t\t//If there are already outputs and we have initial data, propogate it now! \n\t\tif(this.getOutputs().length && this.length){\n\t\t\tthis.setup();\n\t\t}\n\t\t//ProTip: this^ will overwrite any data already in the DOM that we may wish to scrape (in which \n\t\t//case you should create an empty Binder, run .scrape(), then run .fillOut())\n\n\n\t} //end of constructor\n\tBinder.prototype=Object.create(dep.Smarties.Object.prototype);\n\tObject.assign(Binder.prototype,proto.prototype)//add common methods\n\tObject.defineProperty(Binder.prototype, 'constructor', {value: Binder});\n\n\n\t//Static class variables\n\tObject.assign(Binder,proto.static);\n\tObject.defineProperties(Binder,{\n\t\t_baseAttr:{value:'xxx-bind'}\n\t\t,_instances:{value:dep.BetterLog.BetterMap()}\n\t\t,_defaultOptions:{value:{\n\t\t\tchildren:'complex' //used by smarties.Object only. Can be changed to 'primitive'. Changing to 'smart' will\n\t\t\t\t\t\t\t   //not affect how this binder works, but won't break anything\n\n\t\n//2020-03-30: not using this for now... in near future add options that throttle events coming out of certain inputs\n\t\t\t,ignoreTimeout:3000 //When typing in inputs, ignore updates on that input for this many ms after\n\t\t\t\t\t\t\t\t//each keystroke... increase this number if the value bound to those inputs\n\t\t\t\t\t\t\t\t//can/tend to get changed by others during typing...\n\n\t\t}}\n\t\t\n\t\t//static options used by entire class. These CAN be changed at runtime. Do so BEFORE interacting with this clas\n\t\t//in any way\n\t\t,_staticOptions:{value:{ \n\t\t\tinputDebounce:100 //Don't update the value of inputs for this many ms after they've emitted 'input'. This prevents \n\t\t\t\t\t\t\t   //loops that especially affect text inputs where you risk loosing the last typed characters if\n\t\t\t\t\t\t\t   //you're a fast enough typer on a slow enough system\n\n\t\t}}\n\t});\n\t\n\n\n\t/*\n\t* Create a Binder on top of an existing smarty\n\t* @param <SmartObject> smarty\n\t* @return $smarty\n\t*/\n\tBinder.upgradeSmarty=function upgradeSmarty(targetClass,options,smarty){\n\t\tif(!smarty || smarty.isSmart!='SmartObject')\n\t\t\tbu._log.makeTypeError(\"<SmartObject>\",smarty).throw();\n\n\t\tBinder.call(smarty,targetClass,options,smarty);\n\n\t\treturn smarty;\n\t}\n\n\n\n\n\n\t/*\n\t* This method can be called once to setup all Binders (ie. scrape for data and output default values), \n\t* as well as 2-way binding.\n\t*\n\t* NOTE: If this method is NOT called Binders will only propogate future changes to their smarties\n\t*/\n\tBinder._init=bu.once(function initBinders(){\n\t\t//Any binders that were created before there where outputs, propogate them now...\n\t\tBinder._instances.forEach(binder=>{\n\t\t\tif(!binder._private.isSetup){\n\t\t\t\tbinder.setup();\n\t\t\t}\n\t\t})\n\n\t\tBinder._setupTwoWayBinding();\n\t\t\n\t\tBinder._automaticallyBind();\n\t})\n\t\n\n\t//Since ^ can optionally be called but doesn't have to be, we check a few seconds after this file has\n\t//loaded and warn if it hasn't been, just so the dev knows he may be forgetting something\n\tsetTimeout(function BinderInitCheck(){\n\t\tif(!Binder._setupTwoWayBinding._once){\n\t\t\tbu._log.note(\"You have not run Binder._setupTwoWayBinding() which means binding is only one way, ie. any changes\"\n\t\t\t\t+\" made by the user to DOM inputs won't affect the Binder (and will be overwritten if the Binder later changes\");\n\t\t}\n\n\t\tif(!Binder._automaticallyBind._once){\n\t\t\tbu._log.note(\"You have not run Binder._automaticallyBind() which means current data won't be automatically\"\n\t\t\t\t+\" propogated to new nodes, instead you have to call .triggerUpdate(node) manually, or wait for the data to change\")\n\t\t}\n\t},3000)\n\n\n\n\n\n\n\n\t/*\n\t* Parse as much info about an elem as possible and store it on the elem itself. This can save crucial ms \n\t* when we want a responsive interface later\n\t*\n\t* @param <HTMLElement> elem\n\t*\n\t* @return <Binder>|undefined \tThe appropriate binder if one was found, else undefined\n\t* @no-throw\n\t* @call(<Binder>|any) \tFor logging purposes only\n\t*/\n\tBinder._parseElem=parseElem;\n\tfunction parseElem(elem){\n\t\tlet binder=getBinder.call(this,elem);\n\t\tif(binder){\n\t\t\tgetBindInstructions.call(this,elem); //may set empty, ie. you need to forgetElem() for this to change\n\t\t\tfindKeyBoundToValue.call(this,elem); //may set empty, ie. you need to forgetElem() for this to change\n\t\t}\n\t\treturn binder;\n\t}\n\n\t/*\n\t* Removes all 'shortcut'/'lookups' set on an elem, allowing everything to be parsed a-new. This\n\t* function should be called if you change instructions etc.\n\t*\n\t* @param <HTMLElement> elem\n\t*\n\t* @return void\n\t* @no-throw\n\t*/\n\tBinder._forgetElem=forgetElem;\n\tfunction forgetElem(elem){\n\t\t//DevNote: If you create another prop in some function, you should add it to this list\n\t\tdelete elem[BINDER];\n\t\tdelete elem[INSTRUCTIONS];\n\t\tdelete elem[KEY];\n\t\tdelete elem[V_INST];\n\t}\n\n\n\t/*\n\t* Get the <Binder>, if any, used on an elem\n\t*\n\t* NOTE: This function stores a reference to binder on the elem itself for future lookup speed.\n\t*\t\tUse Binder._forgetElem() to remove this and other similar lookups.\n\t*\n\t* @param <HTMLElement> elem\n\t* @return <Binder>|undefined\n\t*/\n\tBinder._getBinder=getBinder;\n\tfunction getBinder(elem){\n\t\tif(!elem.hasOwnProperty(BINDER)){\n\t\t\t//Look for a binder given an elements classes, saving it if found\n\t\t\tlet cls=Array.from(elem.classList).find(cls=>Binder._instances.has(cls));\n\t\t\tif(cls){\n\t\t\t\telem[BINDER]=Binder._instances.get(cls);\n\t\t\t}\n\t\t}\n\t\t//Now return what may be a <Binder> or what may be undefined\n\t\treturn elem[BINDER];\n\t}\n\n\t/*\n\t* Get binder instructions for an elem, organized by the key/prop the instruction is bound to.\n\t*\n\t* NOTE: This function stores a reference to the live parsed instructions on the elem itself for \n\t* \t\tfuture lookup speed. Use Binder._forgetElem() to remove this and other similar lookups.\n\t*\n\t* @param <HTMLElement> elem\n\t* @param @opt string key  \tIf given, a concated array of instructions for that key and '*' is returned\n\t*\t\t\t\t\t\t\t instead of the whole instructions object. Possibly an empty array\n\t*\n\t* @throw <ble TypeError> \tIf $elem isn't an element, bubbles from getInstructions()\n\t*\n\t* @return object \t\t\tAn object where keys match keys for the underlying smart and  values \n\t*\t\t\t\t\t\t\t are arrays of instructions. Possibly an empty object if no instructions \n\t*\t\t\t\t\t\t\t are found. Also @see $key\n\t*\n\t* @call(<Binder>|any) \t \t\tUsed for logging only. Please make sure in other ways that the elem isn't bound to\n\t*\t\t\t\t\t\t\t\t the wrong/another binder instance\n\t*/\n\tBinder._getBindInstructions=getBindInstructions;\n\tfunction getBindInstructions(elem, key){\n\n\t\t//If no live object exists on the elem...\n\t\tif(!elem.hasOwnProperty(INSTRUCTIONS)){\n\t\t\t//...parse instructions anew\n\t\t\telem[INSTRUCTIONS]=proto.getInstructions.call(this,elem,'group'); //throws TypeError, can return empty array\n\n\t\t\t//Also delete the KEY and V_INST which may need to be re-parsed\n\t\t\tdelete elem[KEY];\n\t\t\tdelete elem[V_INST];\n\t\t}\n\n\t\tif(typeof key=='string'){\n\t\t\treturn (elem[INSTRUCTIONS][key]||[]).concat(elem[INSTRUCTIONS]['*']||[]); //this also clones the array so we don't alter the orig\n\t\t}else{\n\t\t\treturn elem[INSTRUCTIONS];\n\t\t}\n\t}\n\n\n\n\n\t/*\n\t* Find which key, if any, in a elem's instructions is bound to the nodes value. This is used to scrape\n\t* both inputs and outputs for data\n\t*\n\t* @param <HTMLElement> elem\n\t*\n\t* @throw <ble TypeError>  \t\tBubbles from getBindInstructions()\n\t*\n\t* @return string|null \t\t\tA key name or null if no key could be found\n\t*\n\t* @call(<Binder>|any) \t \t\tUsed for logging only. Please make sure in other ways that the elem isn't bound to\n\t*\t\t\t\t\t\t\t\t the wrong/another binder instance\n\t*/\n\tBinder._findKeyBoundToValue=findKeyBoundToValue;\n\tfunction findKeyBoundToValue(elem){\n\t\ttry{\n\t\t\tif(!elem.hasOwnProperty(KEY)){\n\t\t\t\tvar key,inst,backup=null,instructions=getBindInstructions.call(this,elem);\n\t\t\t\tloops:\n\t\t\t\t\tfor(key in instructions){\n\t\t\t\t\t\tfor(inst of instructions[key]){\n\t\t\t\t\t\t\tif(inst.fn=='value'){\n\t\t\t\t\t\t\t\tbreak loops; //break loop without unsetting key vv\n\t\t\t\t\t\t\t}else if(inst.fn=='text' || inst.fn=='html'){\n\t\t\t\t\t\t\t\tbackup=key; \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tkey=undefined;\n\t\t\t\t\t}\n\t\t\t\t//------ end of loops\n\n\t\t\t\t//Regardless if we found anything, set this value so we don't check again until having called forgetElem()\n\t\t\t\telem[V_INST]=inst\n\t\t\t\telem[KEY]=key||backup\n\t\t\t}\n\n\t\t\treturn elem[KEY];\n\n\t\t}catch(err){\n\t\t\t(this._log||bu._log).makeError('Failed to identify key bound to value',elem,instructions,err).throw();\n\t\t}\n\t}\n\n\t/*\n\t* From an elem's instructions, find the one binding the value\n\t* @return object|undefined\n\t*/\n\tfunction findValueInstruction(instructions){\n\t\tvar key,inst,backup=null,instructions=getBindInstructions.call(this,node);\n\t\tfor(key in instructions){\n\t\t\tfor(inst of instructions[key]){\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t//If we find the 'value' action, then we return key right away, if we find either of\n\t\t\t\t//the other actions related to scrapeable data we store that key until the end of the\n\t\t\t\t//loop when we've gone through everything\n\t\t\t\tif(inst.fn=='value'){\n\t\t\t\t\treturn inst;\n\t\t\t\t}else if(inst.fn=='text' || inst.fn=='html'){\n\t\t\t\t\tbackup=inst; \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//Still running? Return a possible key used for text or html...\n\t\treturn backup;\n\t}\n\n\n\t/*\n\t* To provide 2-way binding we listen to 'input' events on the <body>. This function sets that up and\n\t* should be called once AFTER the body has been loaded\n\t*\n\t* ProTip: You can check if this has been run by checking Binder._setupTwoWayBinding.hasOwnProperty('_once')\n\t*/\n\tBinder._setupTwoWayBinding=bu.once(function setupTwoWayBinding(){\n\t\t\n\t\t/*\n\t\t  Listen for all input events, but if the target hasn't been marked by ^, ignore it.\n\t\t \n\t\t  NOTE: we update the underlying binder on EVERY SINGLE INPUT event, so for inputs which\n\t\t  \t\tproduce them in large quantities it may be wise to throttle or debounce them at\n\t\t \t\tthe source\n\t\t*/\n\t\tdocument.body.addEventListener('input',binderInputEventHandler,{passive:true, capture:false})\n\t\t\n\t\t/*\n\t\t  Inputs can be focused upon, and not before being focused upon can they produce 'input' events \n\t\t  which we may want to listen to if the input is bound to a <Binder>. So listen for 'focusin' events\n\t\t  on the <body> and use them to attempt to parse the target. If it finds a binder it sets a prop \n\t\t  which binderInputEventHandler() will look for, ignoring the event if it's not there\n\t\t*/\n\t\tdocument.body.addEventListener('focusin',function parseElemOnFocus(event){parseElem(event.target)});\n\n\t\t/*\n\t\t  While inputting quickly on a slow system, the 'input' events caught here^ may be slow to make it\n\t\t  all the way through the binder to .propogateToNodes() which could cause eg. the following scenario:\n\t\t\t- user types 'a'\n\t\t\t- binder starts processing 1st event {target.value:\"a\"}\n\t\t\t- user types 'b'\n\t\t\t- binder starts processing 2nd event {target.value:\"ab\"}\n\t\t\t- 1st event reaches .propogateToNodes() => target.value is set to \"a\"\n\t\t\t- user types 'c' \n\t\t\t- binder starts processing event {target.value:\"ac\"}\t\t\t\t\t<-- b is gone\n\t\t\t- 2nd event reaches .propogateToNodes() => target.value is set to \"ab\"  <-- b came back\n\t\t\t- 3nd event reaches .propogateToNodes() => target.value is set to \"ac\"  <-- b is gone again, forever...\n\n\t\t  and ultimately we've lost a 'b'. To prevent this we mark the input with attr 'inputting' while input\n\t\t  events are flowing in close succession (done by this vv func), and then we have .propogateToNodes()\n\t\t  look for this attribute and NOT run the instruction linked to the value of the input (see \n\t\t  findKeyBoundToValue() which flags that instruction)\n\t\t*/\n\t\tbu.markInputting(Binder._staticOptions.inputDebounce);\n\n\n\t})\n\n\n\t/*\n\t* When new elems are added or classes changed, check if said elem is/was part of a binder and\n\t* update it accordingly. This is done using MutationObserver on <body>\n\t*\n\t* NOTE: This will make sure <body> has loaded before running, since that could drastically\n\t*\t\tslow down load time because every single added elem would trigger MutationObserver\n\t*\n\t* @return void\n\t*/\n\tBinder._automaticallyBind=bu.once(function automaticallyBind(){\n\t\tconst log=proto.getLog();\n\t\t//Make sure body has loaded, else warn and run again in 1s\n\t\tif(!document.body){\n\t\t\tlog.warn(\"Called too early, running again in 1s\");\n\t\t\tsetTimeout(automaticallyBind,1000);\n\t\t\treturn;\n\t\t}\n\n\t\tconst observer = new MutationObserver(function findNewElemsToBind(records) {\n\t\t\tfor(let record of records){\n\t\t\t\tif(record.type=='attributes'){\n\t\t\t\t\t//Figure out which classes where added or which were removed (both can happen in the name record)\n\t\t\t\t\tlet curr=record.target.className.split(' ')\n\t\t\t\t\t\t,old=record.oldValue.split(' ')\n\t\t\t\t\t\t,diff=bu.arrayDiff(curr,old,'noCheck'); //noCheck=>don't check type, we know they're arrays\n\t\t\t\t\t;\n\t\t\t\t\t\n\t\t\t\t\tif(diff[0].length){\n\t\t\t\t\t\t//Classes where added\n\t\t\t\t\t\tfor(let cls of diff[0]){\n\t\t\t\t\t\t\tif(Binder._instances.has(cls)){\n\t\t\t\t\t\t\t\t//An existing elem has just been bound, update it!\n\t\t\t\t\t\t\t\tBinder._instances.get(cls).triggerUpdate(record.target);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(diff[1].length){\n\t\t\t\t\t\t//classes where removed\n\t\t\t\t\t\tfor(let cls of diff[1]){\n\t\t\t\t\t\t\tif(Binder._instances.has(cls)){\n\t\t\t\t\t\t\t\t//An existing elem is no longer bound, remove all traces of the binding so any functions\n\t\t\t\t\t\t\t\t//that only check for certain properties (and not the class, like binderInputHandler) know\n\t\t\t\t\t\t\t\t//the elem is no longer connected\n\t\t\t\t\t\t\t\tforgetElem(record.target);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}else if(record.addedNodes.length){ //implies type='childList'\n\t\t\t\t\t//^We only care about added nodes. If they're deleted they're already gone and forgotten (ie. we \n\t\t\t\t\t// don't store a list of them anywhere, we fetch them every time we propogate an output)\n\n\t\t\t\t\t//While debugging we may wish to profile this\n\t\t\t\t\tif(log.options.lowestLvl<3){\n\t\t\t\t\t\tvar start=bu.timerStart();\n\t\t\t\t\t}\n\n\t\t\t\t\t//Unlike with attributes^ where the target itself is the only elem of interest, and thus can only \n\t\t\t\t\t//be linked to a single <Binder> at most, when elems are added they can contain children and any\n\t\t\t\t\t//of them can be bound to any <Binder> (ie. the same added parent can contain children bound to \n\t\t\t\t\t//different <Binder>s\n\t\t\t\t\tlet i=0;\n\t\t\t\t\tfor(let node of record.addedNodes){\n\t\t\t\t\t\tvar classes=Binder._instances.keys();\n\t\t\t\t\t\tif(bu.nodeType(node)=='element'){ //ignore 'text', 'comment' and 'attribute' nodes\n\t\t\t\t\t\t\tObject.keys(bu.multiQuerySelector(node,classes,'group','self','class')).forEach(\n\t\t\t\t\t\t\t\tcls=>{\n\t\t\t\t\t\t\t\t\tBinder._instances.get(cls).triggerUpdate(node);\n\t\t\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(log.options.lowestLvl<3){\n\t\t\t\t\t\tlog.debug(`It took ${bu.timerStop(start,'nano')}ns to match ${i} Binders`);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\tObject.defineProperty(Binder._automaticallyBind,'observer',{value:observer});\n\t\t  //^make accessible in case we want to cancel it later for some reason\n\n\n\t\t\n\t\tobserver.observe(document.body, {\n\t\t  \t//Watch for the targetClass being added/removed from an elem, running parseElem()+triggerUpdate() \n\t\t  \t//or forgetElem()\n\t\t  \tattributes: true\n\t\t  \t,attributeFilter: ['class']\n  \t\t\t,attributeOldValue: true\n\n  \t\t\t//Watch for elements being added (then we can check for targetClass and run parseElem()+triggerUpdate())\n  \t\t\t,childList: true \t\t\n\n  \t\t\t//Watch the entire DOM\n\t\t\t,subtree: true\n\t\t\t\n\t\t})\n\n\t})\n\n\n\n\t/*\n\t* @param <Event> event \t\tA DOM 'input' event dispatched from ANY input (we check if it's meant for\n\t*\t\t\t\t\t\t\ta Binder inside this handler)\n\t*/\n\tfunction binderInputEventHandler(event){\n\t\t//Check that the input comes from a bound target, and that we're not currently ignoring said input\n\t\tif(event.target[BINDER] && !event.target.hasAttribute('xxx-bind_ignore')){\n\t\t\tlet self=event.target[BINDER];\n\n\t\t\t//Find the key that solves (elem.value == self[key]). Since this is an input and a user has\n\t\t\t//actually changed it it's highly likely that we find one... but if we don't we log and exit\n\t\t\tlet key=findKeyBoundToValue.call(self,event.target);\n\t\t\tif(key==undefined){\n\t\t\t\tself._log.warn(\"Couldn't find a key on input bound to this Binder.\",elem,self);\n\t\t\t\treturn;\n\t\t\t}\n\n\n\t\t\t//Get the value depending on...\n\t\t\tlet value = (event.target.type == 'checkbox' ? event.target.checked : event.target.value)\n\t\t\n\t\t\t//...and update the value on every change. \n\t\t\t//my not be a good idea to bind textboxes where users write a whole novel...\n\t\t\tself.set(key,value,{target:event.target,src:'input'});\n\t\t\t//NOTE: if the input changes rapidly/frequently and all intermittent values are NOT of interest\n\t\t\t//      you can either: a) throttle the events being emitted by the input, and/or b) use the \n\t\t\t//      'throttle' or 'debounce' options of the underlying Smarty to afffect the 'change' events\n\t\t\t//\t\tcomming from it and handled by dataEventCallback() here\n\n\t\t\t//Extra... Necessary?? Emit the input-event on the binder\n\t\t\tself.emit('input',event);\n\t\t}\n\t}\n\n\n\n\t/*\n\t* Event handler for smarties.Object's '_event'. \n\t* @call(<Binder>)\n\t*/\n\tfunction dataEventCallback(event){\n\t\t//This is the reason we don't call propogateToNodes directly, which can be called with a subset of\n\t\t//all nodes related to the key (which is what forceUpdate() does)\n\t\tvar nodes=getNodeArray.call(this,event.key);\n\t\t\n\t\tif(nodes.length){\n\t\t\tpropogateToNodes.call(this,nodes,event);\n\t\t\n\t\t}else if(this._log.options.lowestLvl<3){\n\t\t\tself._log.last().addHandling(`Ignoring <${evt}> event for key '${key}'`);\n\t\t\t\t//^The last entry on our log will be the 'no nodes connected to this binder' created by getNodeArray()\n\t\t}\n\t}\n\n\n\n\n\n\n\n\n\n\t//Define getter for inputs and outputs for ease\n\tBinder.prototype.getOutputs=function(){\n\t\treturn Array.from(document.getElementsByClassName(this._private.targetClass))\n\t};\n\tBinder.prototype.getInputs=function(){\n\t\treturn this.getOutputs.filter(bu.isInput());\n\t};\n\n\n\t/*\n\t* Prepare the binder to be used. Now calling is only done to setup the initial state and make sure\n\t* the initial input event gets parsed, after that it will have happened anyway...\n\t*\n\t* @return <Binder>\n\t*/\n\tBinder.prototype.setup=function(){\n\t\tif(this._private.isSetup){\n\t\t\tthis._log.warn('Setting up binder again...');\n\t\t}else{\n\t\t\tthis._log.debug('Setting up binder...');\n\t\t\tthis._private.isSetup=true;\n\t\t}\n\t\t//Parse all instructions so they're ready to go (for speed later). This is also necessary in\n\t\t//case there are inputs, else the first input event will be missed.\n\t\tthis.parseAllElems();\n\n\t\t//Before outputting anything, scrape for any data so we can save it for intentional later use and/or\n\t\t//so we can warn that you might have forgot to call .scrape('assign')\n\t\tif(!this._private.scraped && !bu.isEmpty(this.scrape('return'))){\n\t\t\tthis._log.warn(\"Possibly overwriting data already in the DOM. Did you forget to call .scrape() \"\n\t\t\t\t+\"before .setup()? Remember, keys which only exist in the DOM will be set to their Binder-\"\n\t\t\t\t+\"value which is 'undefined' (which in turn may set certain inputs to their default value)\"\n\t\t\t\t,{inDom:this._private.scraped,inBinder:this.copy()});\n\t\t}\n\n\t\t//Output initial data to the DOM.\n\t\tthis.triggerUpdate();\n\t\t\t\n\n\t\treturn this;\n\t}\n\n\n\t/*\n\t* Although it will happen automatically when the information is needed, this method will\n\t* parse all bound elems right now\n\t*\n\t* @return <Binder>\n\t*/\n\tBinder.prototype.parseAllElems=function(){\n\t\tthis.getOutputs().forEach(parseElem.bind(this));\n\t\treturn this;\n\t}\n\n\n\n\t/*\n\t* Scrape for data on all nodes connected to this binder. The scraped data will be stored on this._private.scraped\n\t*\n\t* @param string whatToDo \tAccepted values:\n\t*\t\t\t\t\t\t\t\t'assign' --> default. assigns the scraped data and returns <Binder>\n\t*                               'return' --> returns the scraped data without assigning it\n\t*\n\t* @return object|<Binder>\n\t*/\n\tBinder.prototype.scrape=function(whatToDo='assign'){\n\t\tthis._log.trace(\"Scraping DOM for values...\");\n\n\t\t//First get all the data...\n\t\tvar data={}, self=this;\n\t\tthis.getOutputs().forEach(function scrapeDataCallback(node){\n\t\t\tlet key=findKeyBoundToValue.call(self,node);\n\t\t\tif(!key)\n\t\t\t\treturn;\n\t\t\tlet value=bu.getValueFromElem(node);\n\t\t\tif(value===undefined || value==='')\n\t\t\t\treturn;\n\t\t\tif(data.hasOwnProperty(key) && data[key]!=value)\n\t\t\t\tthis._log.warn(`Found different values for key '${key}' while scraping. Using the latter:`,data[key],value)\n\t\t\tdata[key]=value;\n\t\t})\n\n\t\t//Store it both for later access AND as a way to check if it's been done\n\t\tthis._private.scraped=data;\n\n\t\t//...then decide what to do with it\n\t\tif(whatToDo=='return'){\n\t\t\treturn data;\n\t\t}else if(whatToDo!='assign'){\n\t\t\tthis._log.warn(\"E_INVAL. scrape() is defaulting to action 'assign'. Passed in value is not valid:\",whatToDo);\n\t\t}\n\t\tthis.assign(data);\n\t\treturn this;\n\t}\n\n\n\n\n\n\n\n\t/*\n\t* Get an array of nodes, either a subset of those connected to this binder or all of them\n\t* \n\t* @param mixed x \t\t\t\tSee switch in function body\n\t*\n\t* NOTE: This function doesn't consider the \"inputting\" attribute, propogateToNodes() does that for the key bound \n\t*\t\tto the nodes value only (since we may eg. want a faulty value to set a class on the <input> in which case\n\t*\t\twe can't ignore the <input> altogether ) \n\t*\n\t* @return array \n\t* @call(this)\t\t\n\t*/\n\tfunction getNodeArray(x){\n\t\t//Step 1: get an array of nodes\n\t\tvar nodes,msg,lvl='debug';\n\t\tblock:{\n\t\t\tlet t=bu.checkType(['nodelist','array','node','string','undefined'],x);\n\t\t\tswitch(t){\n\t\t\t\tcase 'nodelist':\n\t\t\t\t\tx=Array.from(x);\n\t\t\t\tcase 'array':\n\t\t\t\t\tnodes=x.filter(node=>node.classList.contains(this._private.targetClass)); \n\t\t\t\t\tmsg=\"List of nodes passed in, returning only those connected to this binder:\";\n\t\t\t\t\tbreak block;\n\t\t\t\tcase 'node':\n\t\t\t\t\tbu.multiQuerySelector(x,this._private.targetClass,'self','class');\n\t\t\t\t\tmsg=\"Single node passed in, finding all its children connected to this binder:\";\n\t\t\t\t\tbreak block;\n\t\t\t}\n\t\t\t//If we're still running that means x is a string or undefined...\n\n\t\t\tnodes=Array.from(document.getElementsByClassName(this._private.targetClass)); \n\t\t\tif(!nodes.length){\n\t\t\t\t//No need to log the same thing twice in a row... (which otherwise happens a lot, especially when \n\t\t\t\t//using this.assign())\n\t\t\t\tif(this._log.options.lowestLvl<3){\n\t\t\t\t\tmsg=\"No nodes connected to binder\"\n\t\t\t\t\tlet last=this._log.last();\n\t\t\t\t\tif(last.msg!=msg || last._age>1000){\n\t\t\t\t\t\tbreak block;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn [];\n\t\t\t}else{\n\t\t\t\tlvl='trace';\n\t\t\t\tswitch(t){\n\t\t\t\t\tcase 'undefined':\n\t\t\t\t\t\tmsg=\"Nothing passed in, getting all nodes connected to this binder:\";\n\t\t\t\t\t\tbreak block;\n\n\n\t\t\t\t\tcase 'string':\n\t\t\t\t\t\t//a \"key filter\" passed in, ie. get nodes bound to a specific key of this binder\n\t\t\t\t\t\tmsg=`Getting nodes bound to key '${x}':`;\n\t\t\t\t\t\tnodes=nodes.filter(node=>{\n\t\t\t\t\t\t\tvar instructions=getBindInstructions.call(this,node); //only throws if node isn't a node\n\t\t\t\t\t\t\treturn instructions.hasOwnProperty(x)||instructions.hasOwnProperty('*');\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak block;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthis._log.throw('BUGBUG: util.checkType() returned unexpected value:',t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvar logargs=[msg,nodes,this];\n\t\t\n\t\t//Step 2: remove any we're ignoring\n\t\tvar ignored=bu.extractItems(nodes,function(n,i,a){\n\t\t\treturn n.hasAttribute('xxx-bind_ignore')\n\t\t});\n\t\tif(ignored.length){\n\t\t\tlogargs.splice(2,\"Ignored flagged elems:\",ignored);\n\t\t}\n\n\t\t//We do it this way so so production nothing gets created at all... saving some cycles...\n\t\tthis._log[lvl].apply(this._log,logargs);\n\t\t\n\n\t\treturn nodes;\n\n\t}\n\n\n\n\n\n\n\n\t/*\n\t* Go through an array of nodes, grouping them by key(s) they're bound to (ie. same node may appear in \n\t* multiple arrays, @see @return)\n\t*\n\t* @param array|nodelist nodes \tArray of nodes\n\t*\n\t* @throw <ble TypeError> \tIf $nodes is bad type\n\t* @throw <ble TypeError> \tIf any item in $nodes isn't a node, bubbles from getBinderInstructions()\n\t*\n\t* @return object \tKeys match those on this.private.data, values are arrays of nodes bound to them \n\t* @call(this) \t\tFor logging purposes\n\t*/\n\tfunction splitNodesByKey(nodes){\n\t\tvar obj={}; //init ret-obj\n\t\tbu.checkType(['array','nodelist'],nodes);\n\t\tvar node;\n\t\tfor(node of Array.from(nodes)){\n\t\t\tlet instructions=getBindInstructions.call(this,node);\n\t\t\tObject.keys(instructions).forEach(key=>{\n\t\t\t\t//Add nodes to child-arrays on ret-obj for the given key\n\t\t\t\tif(obj.hasOwnProperty(key))\n\t\t\t\t\tobj[key].push(node)\n\t\t\t\telse\n\t\t\t\t\tobj[key]=[node];\n\t\t\t})\n\t\t}\n\n\t\treturn obj;\t\t\t\t\t\t\n\t}\n\n\n\n\n\t/*\n\t* Make sure all or a subset of nodes are up to update. This is used by .setup() to set default values. This should \n\t* normally not be needed externally unless:\n\t* \t1. you're changing ._private.data manually so no events are emitted by the underlying <SmartObject>\n\t* \t2. you're not using Binder._automaticallyBind() and then add an element to this binder\n\t*\n\t* @param mixed which \t@see getNodeArray\n\t*\n\t* @return void;\n\t*/\n\tBinder.prototype.triggerUpdate=function(which){\n\t\tthis._log.traceFunc(arguments);\n\t\t// console.warn(\"FORCED UPDATE\",this)\n\t\ttry{\n\t\t\t//First get the nodes we're going to update\n\t\t\tvar nodes=getNodeArray.call(this,which);\n\t\t\tif(!nodes.length){\n\t\t\t\tthis._log.warn(\"Trying to update of empty list of nodes, did this fire too soon? Search term:\",which);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t//Then split them by key (ie. keys on this._private.data)\n\t\t\tvar keyNodesObj=splitNodesByKey.call(this,nodes);\n\n\t\t\tthis._log.debug('Manually updating:',keyNodesObj);\n\n\t\t\t//Then loop through said keys, fetching the value of it and propogating that value to the nodes\n\t\t\tObject.entries(keyNodesObj).forEach(([key,_nodes])=>{\n\n\n//STOPSTOP 2020-04-08: If this.get() returns undefined, should be really propogate... because with initial values that\n//\t\t\t\t\t\tcould create issues eg. when setting a range input which will cause it to set to the middle value instead\n\n\t\t\t\tpropogateToNodes.call(this,_nodes,{key,value:this.get(key)});\n\t\t\t});\n\t\t}catch(err){\n\t\t\tthis._log.error(\"Failed to update:\",which,err);\n\t\t}\n\t}\n\n\n\n\n\n\n\n\t/*\n\t* Output the value of a certain key to nodes on the HTML page \n\t*\n\t* @param array \t\t\tnodes \t\tAn array of nodes bound to @key \t\n\t* @param object \t\tevent \t\tContaining keys: evt, key, value, old\n\t*\n\t* @return void\n\t* @call(this)\n\t* @no_throw\n\t*/\n\tfunction propogateToNodes(nodes,event){\n\t\tthis._log.traceFunc(arguments);\n\t\t//Get an object where keys are actions to take and values are node arrays\n\t\tvar node,inst,instructions;\n\t\tfor(node of nodes){\n\t\t\ttry{\n\t\t\t\t//Get the instructions (as an array) for the key in question, and any marked with '*'\n\t\t\t\tinstructions=getBindInstructions.call(this,node,event.key); //throws TypeError if not a node\n\t\t\t\tif(!instructions.length){\n\t\t\t\t\tthrow `No instructions for '${event.key}' or '*'`\n\t\t\t\t}else{\n\t\t\t\t\t//Now loop through that array and apply each inst\n\n\t\t\t\t\tfor(inst of instructions.values()){\n\t\t\t\t\t\tif(inst==node[V_INST] && node.hasAttribute('inputting')){\n\t\t\t\t\t\t\tthis._log.note(\"Not outputting to currently receiving input.\",inst,event, node);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tthis.executeAction(node,inst,event);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}catch(err){\n\t\t\t\tthis._log.error('Failed to get instruction from node:',{node,instructions},err)\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t}\n\n\n\t/*\n\t* Remove binding from one or more nodes\n\t*\n\t* @param <HTMLElement>|nodelist\n\t*\n\t* @return void\n\t*/\n\tBinder.prototype.unbind=function(nodes){\n\t\tArray.from(nodes).forEach(node=>{\n\t\t\tnode.classList.remove(this._private.targetClass);\n\t\t\tforgetElem(node);\n\t\t//2020-03-30: Not necessary anymore\n\t\t\t// node.classList.remove(this._private.inputClass);\n\n\t\t\t// if(typeof node.xxxBindUnlisten=='function'){\n\t\t\t// \tnode.xxxBindUnlisten();\n\t\t\t// \tdelete node.xxxBindUnlisten;\n\t\t\t// }\n\n\t\t})\n\n\t\treturn \n\t}\t\n\t\t\t\t\n\n\n\n\n\treturn Binder;\n}//correct, we do NOT run this function here, see ./require_all.js\n//simpleSourceMap=\n//simpleSourceMap2=\n\n//# sourceURL=webpack:///./src/xxx-bind.class.js?");

/***/ }),

/***/ "./src/xxx-nav.class.js":
/*!******************************!*\
  !*** ./src/xxx-nav.class.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("//simpleSourceMap=/my_modules/xxx/xxx-nav.class.js\n//simpleSourceMap2=/lib/xxx/xxx-nav.class.js\n\n/*\n* @component Navigator\n* @part-of xxx-framework\n* @description Navigators show and hide elements using various means like url hash. It uses \"logic states\", ie. HIGH \n*              and LOW instead of 'show' and 'hide'. If the 'mode' set on an element is 'inverse', then HIGH=hide \n*              whereas normally HIGH=show. \n* @author plundell\n* @license Apache-2.0\n* @note: This component is required by ./xxx.proto.js, you should not need to access it directly.\n* @depends libbetter\n* @depends ./xxx.proto.js\n* @exports {function} Call this function with the dependencies to get the Navigator constructor\n*\n*\n* TODO 2020-01-09: Change 'key' to 'key' so we don't confuse with element key\n* TODO 2020-02-07: Add '!' to mean 'when all are low', ie. the opposite of '*' => when all are high\n*/\n\n\nmodule.exports=function exportNavigator(dep,proto){;\n\n\tconst bu=dep.BetterUtil;\n\n\t/*\n\t* @param string targetClass\n\t* @opt object options\n\t* @opt object states \t\tKeys are keys, values are booleans (true==high)\n\t*  ^NOTE: this will call .setup($states)\n\t*\n\t* @emit before(method, keys) \tThe method that was called, and the keys it was called with\n\t* @emit after(changed keys) \tAn array of keys that actually changed state (check with navigator for current state of each key)\n\t* @emit failed(key, desired state, nodelist) \tIf propogation fails, a list of those nodes who's instructions failed\n\t*\n\t* @extends BetterEvents\n\t*/\n\tfunction Navigator(targetClass, options={},states=null) {\n\t\t\n\t\t//Register this instance on Navigator._instances\n\t\tproto.addInstance.call(this,targetClass);\n\n\t\tproto.setupPrivateLogEvents.call(this,targetClass,options);\n\n\t\tvar o=this._private.options;\n\n\t\t//Use the targetClass in certain cases when other options have not been given\n\t\to.highlightClass=o.highlightClass || targetClass+'_highlight';\n\t\tthis._private.hashKey=(typeof o.hashRouter=='string' ? o.hashRouter : targetClass);\n\n\t\tthis._private.targetClass=targetClass;\n\n\t\t//Setup actions\n\t\tproto.setupActions.call(this,['show','hide','classif']);\n\n\t\tthis.registerActionHandler('highlight',(x)=>this.executeAction(x.node, {fn:'classif',args:[o.highlightClass]},{value:x.value}))\n\n\t\t\n\t\t// This action is useful when setting the title of a wrapper which shows something (like a popup wrapper). \n\t\t// ProTip: If you use: xxx-nav-title=\"*\" it won't get called each time you HIGH() gets called, but it will get called\n\t\t// each time highOnly() gets called... like when switching between tabs/pages...\n\t\tthis.registerActionHandler('title',(x)=>Navigator.setText.call(this,Object.assign(x,{value:this.getHighKeys().join(',')})));\n\n\t\tif(states)\n\t\t\tthis.setup(states);\n\n\t} //end of constructor\n\tNavigator.prototype=Object.create(dep.BetterEvents.prototype); \n\tObject.assign(Navigator.prototype,proto.prototype); //add common methods\n\tObject.defineProperty(Navigator.prototype, 'constructor', {value: Navigator}); \n\n\t\n\t//Static class variables\n\tObject.assign(Navigator,proto.static);\n\tObject.defineProperties(Navigator,{\n\t\t_baseAttr:{value:'xxx-nav'}\n\t\t,_instances:{value:dep.BetterLog.BetterMap()}\n\t\t,_defaultOptions:{value:{\n\t\t\tshowMultiple:false\n\t\t\t,alwaysShowOne:true\n\t\t\t,highlightClass:null //defaults to targetClass+'_highlight', see constructor\n\t\t\t,defaultHigh:null //default key to show\n\t\t\t,hashRouter:false //if truthy the url hash will be updated and followed by this navigator. If a string is passed,\n\t\t\t\t\t\t\t  //it will be used instead of the targetClass as the key in the hash querystring\n\t\t}}\n\t});\n\t\n\n\n\n\n\t/*\n\t* @param string key \tOptional. If given, only nodes with this key is returned\n\t*\n\t* @param undefined|string|array[string] \tkey \t\tOne or more key's to get, or omitted to get all\n\t*\n\t* @throw <ble> \t\t\t\tIf .setup() hasn't been called yet\n\t* @throw <ble TypeError> \t@see getNavInstructions(). Should not happen since we're using native funcs to build 'all'\n\t*\n\t* @return array[<HTMLElement>,...]\n\t*/\n\tNavigator.prototype.getNodes=function(key){\n\t\t//Make sure it's setup before proceeding.\n\t\tif(!this._private.states){\n\t\t\tthrow this._log.makeError(\"Navigator not setup yet, cannot interact with it\");\n\t\t}\n\n\t\t//Get all elements with valid instructions on the page (parses any new instructions, ignores previously\n\t\t//parsed and failed)\n\t\tvar nodes=Array.prototype.slice.call(document.getElementsByClassName(this._private.targetClass))\n\t\tnodes=nodes.filter(elem=>getNavInstructions.call(this,elem).length);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif(typeof key=='string')\n\t\t\treturn nodes.filter(elem=>elem.xxxNav.hasOwnProperty(key));\n\t\telse if(Array.isArray(key))\n\t\t\treturn nodes.filter(elem=>bu.anyArrayOverlap(key,Object.keys(elem.xxxNav)));\n\t\telse\n\t\t\treturn nodes;\n\t}\n\n\n\t/*\n\t* @return object \tKeys are those of this._private.states, values are arrays of all nodes with \n\t*\t\t\t\t\tinstructions for that key\n\t*\n\t* NOTE: The same elem can exist in multiple of the nested arrays\n\t* NOTE: This will include nodes maked with '*'\n\t*/\n\tNavigator.prototype.getNodesGroupedByKey=function(){\n\t\tvar grouped={};\n\t\tthis.getNodes().forEach(elem=>{\n\t\t\telem.xxxNav.keys().forEach(key=>bu.pushToNestedArray(grouped,key,elem));\n\t\t})\n\t\treturn grouped;\n\t\t\n\t}\n\n\n\n\t/*\n\t* Parse documents for connected nodes and return all keys\n\t*\n\t* @return array[string] \t\n\t*/\n\tNavigator.prototype.getKeys=function(){\n\t\tthis.getNodes();\n\t\treturn Object.keys(this._private.states);\n\t}\n\n\n\t/*\n\t* @return object[arrays] \tKeys are 'high' and 'low', values are arrays of keys that are high/low\n\t*/\n\tNavigator.getKeysByState=function(){\n\t\tvar grouped=bu.groupKeysByValue(this._private.states);\n\t\treturn {high:grouped.true, low:grouped.false};\n\t}\n\n\n\t/*\n\t* @return array[string] \tArray of all HIGH keys\n\t*/\n\tNavigator.prototype.getHighKeys=function(){\n\t\t//Since keys initiate with false, we don't have to check for new ones before getting a list of truthy ones\n\t\treturn Object.entries(this._private.states).filter(keystate=>keystate[1]).map(keystate=>keystate[0]);\n\t}\n\n\t/*\n\t* @return array[string] \tArray of all LOW keys\n\t*/\n\tNavigator.prototype.getLowKeys=function(){\n\t\t//Unlike getHighKeys() we have to look for new keys that may initiate with false\n\t\tthis.getNodes();\n\t\treturn Object.entries(this._private.states).filter(keystate=>!keystate[1]).map(keystate=>keystate[0]);\n\t}\n\n\n\n//2020-02-12: We always want to apply a state since we don't know if new elements have been added/tagged or\n//\t\t\t  if something went wrong last time... so this type of function shouldn't be used\n\t/*\n\t* Check if a given list of key's are exactly those high right now\n\t*\n\t* @return boolean \n\t*/\n\t// Navigator.prototype.sameState=function(keyOrKeys){\n\t// \tvar arr=bu.checkType(['string','array'],keyOrKeys)=='string' ? [keyOrKeys] : keyOrKeys;\n\t// \tvar highs=this.getHighKeys(true);\n\t// \treturn bu.sameArrayContents(highs,arr);\n\t// }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t/*\n\t* Prepare all nodes connected to this navigator and show defaults\n\t*\n\t* @return this \n\t*/\n\tNavigator.prototype.setup=function(states){\n\t\t//Start by setting the private flag. NOTE: that getNodes() relies on this ==true, else it'll throw\n\t\tif(this._private.states){\n\t\t\tthis._log.warn(\"Already setup\",this);\n\t\t\treturn;\n\t\t}else{\n\t\t\tthis._log.info(\"Setting up navigator \"+this._private.targetClass,this);\n\t\t\tif(bu.checkType(['object','undefined'])=='object'){\n\t\t\t\tthis._private.states=bu.objCreateFill(Object.keys(states),false);\n\t\t\t}else{\n\t\t\t\tthis._private.states={};\n\t\t\t}\n\n\t\t\t//Special key '*' is true if any are high, or false if all are low\n\t\t\tObject.defineProperty(this._private.states,'*',{\n\t\t\t\tenumerable:false\n\t\t\t\t,get:()=>Object.keys(this._private.states).some(state=>state)\n\t\t\t\t,set:()=>{} //you cannot set it manually, but we don't want an error...\n\t\t\t})\n\t\t}\n\n\n\t\tvar o=this._private.options;\n\n\t\t//Now set the passed in or  default state on all nodes. This also parses the document for nodes\t\t\n\t\tif(states){\n\t\t\tthis.highOnly(bu.groupKeysByValue(states)['true']);\n\t\t}else if(o.defaultHigh){\n\t\t\tthis.highOnlyDefault();\n\n\t\t}else if(o.alwaysShowOne==true){\n\t\t\to.defaultHigh=this.getKeys()[0];\n\t\t\tthis._log.warn(`defaultHigh not set, but alwaysShowOne==true which forces us to use first `\n\t\t\t\t+`key found as default: ${o.defaultHigh}`);\n\t\t\tthis.highOnlyDefault();\n\n\t\t}else{\n\t\t\tthis.lowAll();\n\t\t}\n\n\t\t//If this nav is using hash... (NOTE: we've already done default^, so that's not included in hash)\n\t\tif(o.hashRouter){\n\t\t\tthis.setupHashRouter();\n\t\t}\n\t\t\t\n\n\t\treturn this;\n\t}\n\n\n\n\n\t/*\n\t* Prepare a single element connected to this navigator, removing it from the navigator if it's no good\n\t*\n\t* @param <HTMLElement> elem\n\t*\n\t* @throw <ble TypeError> \t\t\n\t*\n\t* @return object \t\t\tKeys are keys, values are arrays of instructions for that key. Also has\n\t*\t\t\t\t\t\t\tspecial methods 'keys' and 'values', as well as getter 'length'\n\t*\n\t* @call(this)\n\t*/\n\tfunction getNavInstructions(elem){\n\t\t// console.warn(elem)\n\n\t\tif(!elem.xxxNav){\n\t\t\t//Read instructions from the element and add some handling (like adding click listeners...)\n\t\t\t//NOTE: xxxNav may be empty, but we still store it so we don't check again\n\t\t\telem.xxxNav=proto.getInstructions.call(this, elem, inst=>{\n\n\t\t\t\t//'link' is a psuedo-action which really implies 'open'...\n\t\t\t\tif(inst.fn=='link'){\n\t\t\t\t\tinst.fn='open'\n\n\t\t\t\t\t//...we also set a class to mark it as a link, so we can style it before and after being used\n\t\t\t\t\telem.classList.add('xxx-nav_link'); \n\t\t\t\t}\n\n\t\t\t\t//'open' and 'close' are special cases, they are not actions that affect the node, instead they\n\t\t\t\t//ad a onclick func that changes states on this Navigator (that in turn will trigger actions...)\n\t\t\t\tif(inst.fn=='open' || inst.fn=='close'){\n\t\t\t\t\t\n\t\t\t\t\t//Combine $fn with optional args to get a method from this Nav...\n\t\t\t\t\tvar f=(inst.fn=='open'?'high':'low'),method;\n\t\t\t\t\tif(inst.key=='*'){\n\t\t\t\t\t\tmethod=this[f+'All'].bind(this);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(inst.args.includes('only')) //Remember, of .options.showMultiple==false, this has no effect\n\t\t\t\t\t\t\tf+='Only'\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tf=f.toUpperCase();\n\t\t\t\t\t\tmethod=this[f].bind(this,inst.key);\t\n\t\t\t\t\t}\n\n\t\t\t\t\t//...then add the event\n\t\t\t\t\telem.onclick=()=>{\n\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\t//Tag the elem as 'used' (hads no effect by default, except \n\t\t\t\t\t\t\t//@see '.xxx-nav_link.xxx-nav_used'\n\t\t\t\t\t\t\telem.classList.add('xxx-nav_used');\n\t\t\t\t\t\t\tmethod(); //args have already been bound ^\n\t\t\t\t\t\t}catch(err){\n\t\t\t\t\t\t\tthis._log.error(\"BUGBUG: onclick failed. \",err);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t//Now return 'drop' since this shouldn't be treaded as an instruction by propogateToNodes().\n\t\t\t\t\t//But first add the no-action tag so we don't warn\n\t\t\t\t\telem.setAttribute('xxx-nav_noaction','');\n\t\t\t\t\treturn 'drop';\n\t\t\t\t}\n\n\t\t\t},'group');\n\n\t\t\t// console.log(elem,elem.xxxNav.keys());\n\n\t\t\t//Make sure all keys exist as a state on the private var and a getter on this instance\n\t\t\telem.xxxNav.keys().forEach(key=>{\n\t\t\t\tif(!this._private.states.hasOwnProperty(key)){\n\t\t\t\t\tthis._private.states[key]=false\n\t\t\t\t\tObject.defineProperty(this,key,{get:()=>this._private.states[key]});\n\t\t\t\t}\n\t\t\t})\n\n\t\t}\n\n\t\treturn elem.xxxNav;\n\t}\n\n\n\n\n\n\n\t/*\n\t* Tell this navigator to start updating and following the uri hash\n\t*\n\t* @return void\n\t*/\n\tNavigator.prototype.setupHashRouter=function(){\n\t\tif(this._private.followHash || this._private.setHash){\n\t\t\tthis._log.note(\"Hash routing already running on this Navigator\");\n\t\t\treturn;\n\t\t}\n\t\tthis._log.info(\"Starting hash routing...\");\n\n\t\ttry{\n\t\t\t//Define method to read the current hash and navigate accordingly (storing it will\n\t\t\t//allow us to remove it later if wanted)...\n\t\t\tthis._private.readAndFollowHash=()=>{\n\t\t\t\tvar ourHash=bu.queryStrToObj(window.location.hash)[this._private.hashKey];\n\t\t\t\tif(!ourHash){\n\t\t\t\t\tthis._log.trace(\"Hash changed but doesn't reference our navigator:\",window.location.hash);\n\t\t\t\t// }else if(this.sameState(ourHash)){\n\t\t\t\t// \tthis._log.trace(\"Hash changed, but we're already in right state:\",ourHash);\n\t\t\t\t}else{\n\t\t\t\t\t//We should only be here if we're not already showing the correct stuff, to \n\t\t\t\t\t//further avoid any loops\n\t\t\t\t\tthis._log.trace(\"Hash changed, following our part:\",ourHash);\n\t\t\t\t\tthis.highOnly(ourHash);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//... then trigger it right away to follow any initial hash\n\t\t\tthis._private.readAndFollowHash();\n\n\t\t\t//... and then start listening for the hash to change. This event only fires if a change \n\t\t\t//actually occurs, so no risk for loops\n\t\t\twindow.addEventListener(\"hashchange\", this._private.readAndFollowHash);\n\n\n\n\t\t\t//Then start listening for changes on the local object and set the hash accordingly (again \n\t\t\t//we store it so we can remove later\n\t\t\tthis._private.setHash=this.on('after',(changed)=>{\n\t\t\t\t//No need to waste the cpu cycles if nothing has changed\n\t\t\t\tif(changed.length){\n\t\t\t\t\t//Get high keys as array or string depending on option showMultiple\n\t\t\t\t\tvar keys=this.getHighKeys(true); //true == discard star\n\t\t\t\t\tif(this._private.options.showMultiple==false){\n\t\t\t\t\t\tkeys=keys[0];\n\t\t\t\t\t\t//^ will be undefined if no keys are selected... remember to check for that vv\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//Parse the current hash in case it's being used for more than this navigator, update only\n\t\t\t\t\t//our nav's part, then set back\n\t\t\t\t\tvar hashObj=bu.queryStrToObj(window.location.hash);\n\t\t\t\t\tif(!keys || !keys.length){\n\t\t\t\t\t\tdelete hashObj[this._private.hashKey];\n\t\t\t\t\t}else{\n\t\t\t\t\t\thashObj[this._private.hashKey]=keys;\n\t\t\t\t\t}\n\t\t\t\t\tvar hashStr=bu.objToQueryStr(hashObj);\n\t\t\t\t\thashStr=hashStr?\"#\"+hashStr:hashStr; //not needed for setting, but needed for comp here vv\n\t\t\t\t\tif(window.location.hash!=hashStr){\n\t\t\t\t\t\tthis._log.trace(`Updating uri hash: ${window.location.hash} => ${hashStr}`)\n\t\t\t\t\t\twindow.location.hash=hashStr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t}catch(err){\n\t\t\tthis._log.error(\"BUGBUG\",err);\n\t\t\tthis.stopHashRouter();\n\t\t}\n\n\t\treturn;\n\t}\n\n\n\t/*\n\t* Stop hash routing if setup (ie. no danger calling this whenever)\n\t*\n\t* @return void\n\t*/\n\tNavigator.prototype.stopHashRouter=function(){\n\t\tvar wasRunning=false;\n\t\t\n\t\tif(this._private.setHash){\n\t\t\ttry{\n\t\t\t\tthis.off(this._private.setHash);\n\t\t\t\twasRunning=true;\n\t\t\t}catch(err){\n\t\t\t\tthis._log.error(\"BUGBUG\",err);\n\t\t\t}\n\t\t\tdelete this._private.setHash;\n\t\t}\n\n\t\tif(this._private.readAndFollowHash){\n\t\t\ttry{\n\t\t\t\twindow.removeEventListener(\"hashchange\", this._private.readAndFollowHash);\n\t\t\t\twasRunning=true;\n\t\t\t}catch(err){\n\t\t\t\tthis._log.error(\"BUGBUG\",err);\n\t\t\t}\n\t\t\tdelete this._private.readAndFollowHash;\n\t\t}\n\n\t\tif(wasRunning){\n\t\t\tthis._log.debug(\"Stopped hash routing on this Navigator\");\n\t\t}else{\n\t\t\tthis._log.note(\"Hash routing isn't running on this Navigator, nothing to stop\");\n\t\t}\n\n\t\treturn;\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t/*\n\t* Log and emit what's about to happen\n\t*\n\t* @param string which \t \tThe function called\n\t* @param array \tkeys\t\n\t*\n\t* @emit 'before' ($which, $keys)\n\t*\n\t* @return object \t\t\tcopy of this._private.states (star included)\n\t* @call(this)\n\t*/\n\tfunction emitBefore(which,keys){\n\t\tthis._log.trace(which,keys);\n\t\tthis.emit('before',which,keys);\n\t\tvar before=Object.assign({},this._private.states);\n\t\tbefore['*']=this._private.states['*'];\n\t\treturn before;\n\n\t}\n\n\n\t/*\n\t* Determine which states changes, then emit and return that array\n\t*\n\t* @param object before \t \t@see emitBefore\n\t*\n\t* @emit 'after' (array) \tEmits with array of string keys, those who's state changed\n\t*\n\t* @return array[string] \tArray of keys that changed state (star included if changed). NOTE: To see what they changed\n\t*\t\t\t\t\t\t\tto you have to check with the navigator...\n\t* @call(this)\n\t*/\n\tfunction emitAfter(before){\n\t\tvar changed=[],key;\n\t\tfor(key in this._private.states){\n\t\t\tif(this._private.states[key]!=before[key]){\n\t\t\t\tchanged.push(key)\n\t\t\t}\n\t\t}\n\t\tthis.emit('after',changed);\n\t\treturn changed;\n\t}\n\n\n\n\n\t/*\n\t* Make sure we have an array or keys and that NO STAR is included since we handle that manually\n\t*\n\t* @param string|array[string...] keyOrKeys\n\t*\n\t* @return array\n\t*/\n\tfunction prepareKeyArray(keyOrKeys){\n\t\t//Make sure we have an array for same handling and so it can contain '*' as well\n\t\tvar keys=bu.checkType(['string','array'],keyOrKeys)=='string' ? [keyOrKeys] : keyOrKeys;\n\n\t\t//Remove star\n\t\tlet star=keys.indexOf('*')\n\t\tif(star>-1)\n\t\t\tkeys.splice(star,1)\n\n\t\treturn keys;\n\t}\n\n\n\t/*\n\t* Set an key to HIGH.  Respects option showMultiple\n\t*\n\t* @param mixed keyOrKeys \t\t@see makeHighArr()\n\t*\n\t* @return array\n\t*/\n\tNavigator.prototype.HIGH=function(keyOrKeys){\n\n\t\t//If we're only showing a single at a time, switch over to that method...\n\t\tif(this._private.options.showMultiple==false)\n\t\t\treturn this.highOnly(keyOrKeys);\n\t\t\n\t\t//Make sure we have an array and that it doesn't include '*' which we handle manually\n\t\tvar keys=prepareKeyArray(keyOrKeys);\n\t\t\n\t\tvar before=emitBefore.call(this,keys);\n\n\n\t\t//Set all these keys to high, regardless what they were since new nodes may have been \n\t\t//introduced...\n\t\tvar groupedNodes=this.getNodesGroupedByKey();\n\t\tkeys.forEach(key=>propogateToNodes.call(this,key,true,groupedNodes[key]))\n\n\t\tif(groupedNodes.hasOwnProperty('*') && !keys.includes('*')) //don't do again if keys already contained '*'\n\t\t\tpropogateToNodes.call(this,'*',true,groupedNodes['*']); //At least one is high, so set * to high\n\n\t\treturn emitAfter.call(this,before);\n\n\t}\n\n\n\n\t/*\n\t* Show a single or multiple keys, hiding all others\n\t*\n\t* @param string|array keyOrKeys\n\t*\n\t* @return array[<HTMLElement>] \tArray of nodes that where changed\n\t*/\n\tNavigator.prototype.highOnly=function(keyOrKeys){\n\t\t//Make sure we have an array and that it doesn't include '*' which we handle manually\n\t\tvar keys=prepareKeyArray(keyOrKeys);\n\n\t\t//In case we're only allowed to high one...\n\t\tif(this._private.options.showMultiple==false && keys.length>1){\n\t\t\tthis._log.throw(`Cannot set multiple keys to high (since option showMultiple==false). Got:`,keys);\n\t\t}\n\n\t\t//Them emit and store the state\n\t\tvar before = emitBefore.call(this,'highOnly',keys);\n\n\t\t//Regardless which states are what, we're going to make sure that ALL ELEMENTS get the right state\n\t\tvar key,groupedNodes=this.getNodesGroupedByKey();//also makes sure all nodes are parsed\n\t\tfor(key in groupedNodes){\n\t\t\tif(key=='*')\n\t\t\t\tcontinue; //we do this guy after, else it'll go to false now which may make something blink\n\n\t\t\t//Determine if it should be high or not...\n\t\t\tlet setHigh=keys.includes(key);\n\t\t\t//...then do it!\n\t\t\tpropogateToNodes.call(this,key,setHigh,groupedNodes[key]); //pass in nodes so we don't search again...\n\t\t}\n\n\t\tif(groupedNodes.hasOwnProperty('*')) \n\t\t\tpropogateToNodes.call(this,'*',true,groupedNodes['*']); //At least one is high, so set * to high\n\n\t\t//ProTip: It doesn't matter if not all the keys exist 'before' since their existence after is enough\n\n\t\t//Now emit the changed keys (NOTE: this does not include any information about if any nodes actually\n\t\t//changed or if there were any failure applying stuff)\n\t\treturn emitAfter.call(this,before);\n\t}\n\n\n\t/*\n\t* Show all elements. \n\t*\n\t* @throw <BLE> \t\t\tIf options showMultiple==false \n\t* @return array \t\t@see this.HIGH()\n\t*/\n\tNavigator.prototype.highAll=function(){\n\t\treturn this.HIGH(this.getKeys());\n\t}\n\n\t\n\t/*\n\t* @throw Error \t\tIf no default exists\n\t* @return array \t@see this.highOnly()\n\t*/\n\tNavigator.prototype.highOnlyDefault=function(){\n\t\tif(this._private.options.defaultHigh)\n\t\t\treturn this.highOnly(this._private.options.defaultHigh);\n\t\telse\n\t\t\tthis._log.throw(\"No default elem set\");\n\t}\n\n\n\n\n\n\t/*\n\t* Set one or more keys to LOW. If all keys are low after that, we'll also set special key '*' to LOW. \n\t* Respects options defaultHigh and alwaysShowOne.\n\t*\n\t* @param string|array keyOrKeys\t\t\n\t*\n\t* @throws Error \t\t\tIf you're trying to hide the last element and options alwaysShowOne==true && defaultHigh==null\n\t* @return array[<elem>...] \tArray of elements that where hidden this time\n\t*/\n\tNavigator.prototype.LOW=function(keyOrKeys,...secret){\n\t\tvar keys=prepareKeyArray(keyOrKeys)\n\n\t\t//Determine the change...\n\t\tvar [highAfter,noEffect,changed] = bu.arrayDiff(this.getHighKeys(),keys);\n\n\t\t//If at least one must remain high, make sure we're not about to violate that\n\t\tif(this._private.options.alwaysShowOne && !highAfter.length){\n\t\t\t//Ok, so we are going to violate that... maybe it can be saved with the default?\n\t\t\tif(this._private.options.defaultHigh){\n\t\t\t\treturn this.highOnly(this._private.options.defaultHigh)\n\t\t\t}else{\n\t\t\t\tthis._log.throw(\"Cannot LOW last element(s) with options alwaysShowOne==true && defaultHigh==null\",changed);\n\t\t\t}\n\t\t}\n\t\t//Remove the star since we determine here if that gets LOW'd or not\n\t\tvar before=emitBefore.call(this,secret.includes('lowAll')?'lowAll':'LOW',keys); //secret arg... \n\t\t\n\t\tvar groupedNodes=this.getNodesGroupedByKey();\n\t\tkeys.forEach(key=>propogateToNodes.call(this,key,false,groupedNodes[key]))\n\n\t\t//Now if none are high after, also make star LOW (unless secret flag is set)\n\t\tif(!highAfter.length && groupedNodes.hasOwnProperty('*') && !secret.includes('ignoreStar') )\n\t\t\tpropogateToNodes.call(this,'*',false,groupedNodes['*']);\n\n\t\treturn emitAfter.call(this,before);\n\t}\n\n\n\t/*\n\t* Hide all elements\n\t* @throw <BLE> \t\t\tIf options alwaysShowOne==true\n\t* @return array \t\t@see this.LOW()\n\t*/\n\tNavigator.prototype.lowAll=function(){\n\t\tif(this._private.options.alwaysShowOne==true)\n\t\t\tthis._log.throw(\"LOWing all not permitted on this navigator, see option alwaysShowOne==true\");\n\t\t\n\t\tlet keys=this.getKeys();\n\t\treturn this.LOW(keys);\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//TODO 2020-03-16: Something seems to double trigger... when switching tabs we seem to do the same thing \n//\t\t\t\t\ttwice... check it out step by step...\n\t/*\n\t* Propogate the change to all elements bound to a specific key, keys or all nodes\n\t*\n\t* @param string \t\t\tkey \t\t\n\t* @param boolean \t\t\tstate \t\t\n\t* @param array|undefined \tnodes  \t\t\n\t*\n\t* @return void\n\t*\n\t* @call(this)\n\t* @no_throw\n\t*/\n\tfunction propogateToNodes(key,state,nodes){\n\t\ttry{\n\t\t\tlet a=this._private.states[key]==state ? ['Ensuring','is','trace'] : ['Setting','to','info'];\n\t\t\tthis._log[a[2]](`${a[0]} key '${key}' ${a[1]} ${state?'HIGH':'LOW'}. Nodes:`,nodes);\n\n\t\t\tvar node,inst,failed=[],event={key, value:state}; \n\t\t\tfor(node of nodes){\n\t\t\t\ttry{\n\t\t\t\t\tvar instructions=node.xxxNav[key]\n\t\t\t\t\tif(!instructions || !instructions.length){\n\t\t\t\t\t\tthrow new Error(\"BUGBUG: Node doesn't have instructions but still got into propogateToNodes()\");\n\t\t\t\t\t}else{\n\t\t\t\t\t\t//Now loop through that array and apply each inst\n\t\t\t\t\t\tfor(inst of instructions){\n\t\t\t\t\t\t\tthis.executeAction(node,inst,event);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}catch(err){\n\t\t\t\t\tthis._log.error('Failed to propogate to node:',{node,instructions},err)\n\t\t\t\t\tfailed.push(nodes);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//If any failed, emit an error with them\n\t\t\tif(failed.length)\n\t\t\t\tthis.emit('failed',key,state,failed);\n\n\t\t\t//If all didn't fail, set the new state... (the failed ones we'll have to deal with seperately)\n\t\t\tif(!nodes.length|| failed.length!=nodes.length)\n\t\t\t\tthis._private.states[key]=state;\n\n\n\t\t\treturn;\n\n\t\t}catch(err){\n\t\t\tthis._log.error(\"BUGBUG:\",err,arguments)\n\t\t}\n\t}\n\n\n\t//Create a style for the link\n\tbu.createCSSRule('.xxx-nav_link','text-decoration: underline; color:blue;');\n\tbu.createCSSRule('.xxx-nav_link.xxx-nav_used','color:purple');\n\tbu.createCSSRule('.xxx-nav_link:hover','cursor:pointer;');\n\n\n\n\n\n\t\n\treturn Navigator;\n}//correct, we do NOT run this function here, see ./require_all.js\n//simpleSourceMap=\n//simpleSourceMap2=\n\n//# sourceURL=webpack:///./src/xxx-nav.class.js?");

/***/ }),

/***/ "./src/xxx-repeat.class.js":
/*!*********************************!*\
  !*** ./src/xxx-repeat.class.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("//simpleSourceMap=/my_modules/xxx/xxx-repeat.class.js\n//simpleSourceMap2=/lib/xxx/xxx-repeat.class.js\n\n/*\n* @component Repeater\n* @part-of xxx-framework\n* @author plundell\n* @license Apache-2.0\n* @description Repeaters use standalone/underlying smarties.Array to repeat templates within a target element \n*              in the DOM. \n* @note: This component is required by ./xxx.proto.js, you should not need to access it directly.\n* @depends libbetter\n* @depends ./xxx.binder.js\n* @depends ./xxx.proto.js\n* @depends smarties.Array\n* @exports {function} Call this function with the dependencies to get the Repeater constructor\n*\n* ProTip: If each clone is to contain mutiple pieces of data, then the value of the\n*\t\t  smarties.Array should be used to set classes/data-bind attributes on children of\n*\t\t  the clone for a seperate Binder to use\n*\n* DEPRECATED: If you see empty arrays / instructions it was the old way of preventing Repeater\n*\t\t\t  from warning when you intentionally wanted no actions. The new way is to use\n* \t\t\t\t'{\"x\":\"noaction\"}'\n*\n* Terminology:\n*  \"Pattern\":\n*\t\tRepeaters use pattern instead of regular keys in order for format the value passed to\n*\t\taction functions. The pattern can also make use of the index. Examples:\n*\t\t\tindex=1, value='red', pattern='#' \t\t\t=> \t1\n*\t\t\tindex=2, value='blue', pattern='$'\t\t\t=>\t'blue'\t\n*\t\t\tindex=3, value='green', pattern='#-$'\t\t=>\t'3-green'\n*\t\t\tindex=4, value={foo:'bar'}, pattern='$'\t\t=>\t{foo:'bar'} \t\t*live object\n*\t\t\tindex=4, value={foo:'bar'}, pattern='foo'\t=>\t'foo' \t\t\t\t*probably not what you want\n*\t\t\tindex=4, value={foo:'bar'}, pattern='${foo}'=>\t'bar'\n*\t\t\tindex=4, value={foo:'bar'}, pattern='#$'\t=>\t\"4{'foo':'bar'}\"\t*probably not what you want\n*\t\t\tindex=6, value={foo:'bar',me:{age:30}}, pattern='#-${me.age}${foo}#hat'\n*\t\t\t\t\t\t\t\t\t\t\t\t\t\t=>\t\"6-15bar6hat\"  \n*/\n\n//Export\nmodule.exports=function exportRepeater(dep,proto){\n\n\n\tconst Binder=proto.Binder\n\tconst bu=dep.BetterUtil\n\n\n\n\n\tconst blackhole=document.implementation.createHTMLDocument('blackhole');\n\n\tconst TAG_RID='repeat-index-dependent';\n\n\t/*\n\t* @param string             targetClass\n\t* @param object             options \t\t\t@see defaultOptions\n\t* @param array|smarties.Array  data\n\t*\n\t*\n\t* NOTE: the template will not be removed from the html (unless it's inside the target which will always be emptied), so it \n\t*\t\tshould be hidden or inside a template tag\n\t*\n\t* @extends BetterEvents\t\n\t*/\n\tfunction Repeater(targetClass,options={},data=null){\n\t\ttry{\n\t\t\t//Register this instance on Repeater._instances\n\t\t\tproto.addInstance.call(this,targetClass);\n\t\t\t\n\t\t\tproto.setupPrivateLogEvents.call(this,targetClass,options);\n\n\t\t\t\n\t\t\t/*\n\t\t\t* Create unique version of listener callback since we can share the underlying SmartArray but\n\t\t\t* may wish to manipulate this Repeaters listening status seperately\n\t\t\t*/\n\t\t\tthis._private.dataEventCallback=dataEventCallback.bind(this)\n\n\n\t\t\t/*\n\t\t\t* @prop boolean indexDependentPatterns \tPatterns can use the index of an item ('#'). If any do (either the\n\t\t\t*\t\t\t\t\t\t\t\t\t\tchoice of template, or any of the template nodes) this flag needs  \n\t\t\t*\t\t\t\t\t\t\t\t\t\tto bet set true which will cause a 'change' event to fire anytime \n\t\t\t*\t\t\t\t\t\t\t\t\t\tthe order of the array is affected\n\t\t\t. This implies that anytime you alter the order of the array \n\t\t\t*\t\t\t\t\t\t\t\t\t\t(ie. anything other than adding/deleting the last item or merely \n\t\t\t*\t\t\t\t\t\t\t\t\t\tchanging items in place) you have to run a 'change' event for ALL\n\t\t\t*\t\t\t\t\t\t\t\t\t\tthe affected indexes, which is slow, which is why we don't do it \n\t\t\t*\t\t\t\t\t\t\t\t\t\tunless we have to.\n\t\t\t* @private\n\t\t\t*/\n\t\t\tvar indexDependentPatterns=false;\n\t\t\tObject.defineProperty(this._private,'indexDependentPatterns',{enumerable:true,\n\t\t\t\tget:()=>indexDependentPatterns\n\t\t\t\t,set:(str)=>{\n\t\t\t\t\tif(!indexDependentPatterns){\n\t\t\t\t\t\tif(str && this._private.options.debugMode){\n\t\t\t\t\t\t\tthis._log.warn(\"Possible slowdown! By using patterns with '#', every time you alter the \"\n\t\t\t\t\t\t\t\t+\"order of items (ie. by adding/deleting/moving items in the middle) a 'change' event \"\n\t\t\t\t\t\t\t\t+\"will fire.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tindexDependentPatterns=str;\n\t\t\t\t\t}else if(indexDependentPatterns!=str){\n\t\t\t\t\t\tindexDependentPatterns='both';\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t})\n\n\t\t\t/*\n\t\t\t* @property actions \tHolds callbacks which are invoked by instructions on html nodes\n\t\t\t*\n\t\t\t* NOTE: Actions work differently in Binder and Repeater. In Repeater:\n\t\t\t*   - Repeater WILL create/delete/move nodes\n\t\t\t*\t- Repeater is NOT an instance of a smarty, but has (can share) an underlying smarty\n\t\t\t* \t- Repeater is connected to a specific target node (and replicates the smarty's children to that node)\n\t\t\t*   - When underlying smarty emits 'event', _private.dataEventCallback() is called. It in turn moves/removes\n\t\t\t*\t   an item which doesn't require the action functions, OR it creates+calls action OR it calls action\n\t\t\t*\n\t\t\t* @access private\n\t\t\t*/\n\t\t\tproto.setupActions.call(this);\n\n\t\t//2020-04-01: Not necessary anymore, we watch for changes on <body> and auto-bind\n\t\t\t// //In case classes we apply mean a binder is in effect....\n\t\t\t// var possiblyUpdateBinder=(x)=>{\n\t\t\t// \tif(proto.Binder._instances.has(x.value)){\n\t\t\t// \t\tthis._log.debug(`Repeater applied binder class (${x.value}), forcing binder update: `,x.node);\n\t\t\t// \t\tBinder._instances.get(x.value).forceUpdate(x.node);\n\n\t\t\t// \t}else if(x.old && proto.Binder._instances.has(x.old)){\n\t\t\t// \t\tthis._log.debug(`Repeater removed binder class (${x.old}), unbinding: `,x.node);\n\t\t\t// \t\tproto.Binder._instances.get(x.old).unbind(x.node);\n\t\t\t// \t}\n\n\t\t\t// }\n\t\t\t// this.registerActionHandler('class',possiblyUpdateBinder,'silent');\n\t\t\t// this.registerActionHandler('classif',possiblyUpdateBinder,'silent');\n\n\n\t\t\tif(data){\n\t\t\t\tthis._log.debug(\"Setting up data right away...\")\n\t\t\t\tthis.setupData(data);\n\t\t\t}\n\n\t\t}catch(err){\n\t\t\tconsole.error(typeof err, err.constructor.name,err);\n\t\t\tproto.getLog(this).throw('Failed to setup Repeater.',err,arguments);\n\t\t}\n\t}\n\tRepeater.prototype=Object.create(dep.BetterEvents.prototype)\n\tObject.assign(Repeater.prototype,proto.prototype); //add common methods\n\tObject.defineProperty(Repeater.prototype, 'constructor', {value: Repeater});\n\n\t\n\t//Static class variables\n\tObject.assign(Repeater,proto.static);\n\tObject.defineProperties(Repeater,{\n\t\t_baseAttr:{value:'xxx-repeat'}\n\t\t,_instances:{value:dep.BetterLog.BetterMap()}\n\t\t,_defaultOptions:{value:{\n\t\t\tchildren:'complex'//used by smarties.Array created here\n\t\t\t,moveEvent:true //used by smarties.Array created here\n\t\t\t,addGetters:true //used locally and by smarties.Array created here\n\t\t\t,target:null\n\t\t\t,template:`<span xxx-repeat='[{\"value\":\"#\"}]'></span>`\n\t\t\t,debugMode:true //Attributes will be left/added to nodes for debug clarity\n\t\t}}\n\t});\n\n\n\n\n\n\n\n\t/*\n\t* @call(this)\n\t*/\n\t// function storeInstance(name, removeOld=false){\n\t// \t//If we're changing names, remove the old entry\n\t// \tif(removeOld)\n\t// \t\tdelete Repeater._instances[this._private.options.name];\n\n\t// \t//Now add the new entry\n\t// \tthis._private.options.name=bu.getUniqueString(name,Object.keys(Repeater._instances));\n\t// \tRepeater._instances[this._private.options.name]=this;\n\n\t// \t//Lastly, change the name used for logging\n\t// \tif(this._log.options.name!=this._private.options.name){\n\t// \t\tthis._log.debug(`Changing logging name to '${this._private.options.name}'`);\n\t// \t\tthis._log.options.name=this._private.options.name;\n\t// \t}\n\n\t// \treturn;\n\t// }\n\n\n\tObject.defineProperty(Repeater.prototype, 'length', {get: function(){\n\t\tif(bu.varType(this._target)=='node')\n\t\t\treturn this._target.childElementCount;\n\t\telse\n\t\t\treturn 0;\n\t}}); \n\n\n\t/*\n\t* Check if Repeater is setup\n\t*\n\t* @return bool\n\t*/\n\tRepeater.prototype.isSetup=function(){\n\t\tif(typeof this._data=='object' //gets set by setupData()\n\t\t\t  && this._data.hasListener('event',this._private.dataEventCallback) //gets set by setup()\n\t\t){\n\t\t\t//We should be setup now, but it may be that the target has been removed from the DOM, so we check and\n\t\t\t//make sure to destroy if that's the case\n\t\t\tif(bu.varType(this._target)!='node'||this._target.ownerDocument!=document){\n\t\t\t\tthis._log.warn(\"Target no longer valid\",this._target,this); \n\t\t\t\t// this._log.note(\"Target no longer valid, destroying...\",this._target,this); \n\t\t\t\t// this.destroy(true); //true=>destroy without checking if it's setup, which would cause infinite loop\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}else \n\t\t\treturn false;\n\t}\n\n\n\n\t/*\n\t* Create/set smarties.Array on this._data\n\t*\n\t* @param <smarties.Array>|array|undefined \tdata\n\t*\n\t* @throws Error,TypeError\n\t* @return this \t\t\t\tFor chaining. The data was set on this._data\n\t*/\n\tRepeater.prototype.setupData=function(data){\n\t\t//Don't setup again if already setup...\n\t\tif(this.hasOwnProperty('_data')){\n\t\t\tif(data==undefined)\n\t\t\t\treturn this._data;\n\t\t\telse\n\t\t\t\tthis._log.throw(\"Data already setup on this repeater\");\n\t\t}\n\n\t\tvar sArr;\n\t\tswitch(bu.varType(data)){\n\t\t\tcase 'undefined': //implies data not setup, and nothing passed in\n\t\t\tcase 'array':\n\t\t\t\t//Create new smarty...\n\t\t\t\t// this._log.note(\"Setting up new smarties.Array with options:\",this._private.options);\n\t\t\t\tsArr=new dep.Smarties.Array(this._private.options);\n\t\t\t\t\n\t\t\t\tif(data){ //...and add all data to it\n\t\t\t\t\tsArr.concat(data);\n\t\t\t\t\tthis._log.debug(\"Creating smartArray on repeater with data:\",sArr)\n\t\t\t\t}else{\n\t\t\t\t\tthis._log.note(\"Creating empty smartArray on repeater. Don't forget to populate it later!\");\n\t\t\t\t}\n\n\n\t\t\t\tbreak;\n\t\t\tcase 'object':\n\t\t\t\tif(data.isSmart=='SmartArray'){\n\t\t\t\t\tthis._log.debug(\"Using passed in smartArray on repeater:\",data);\n\t\t\t\t\tsArr=data;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tdefault:\n\t\t\t\tthis._log.throwType(\"array or smarties.Array\",data)\n\t\t}\n\t\tObject.defineProperty(this,'_data',{value:sArr});\n\n\t\t//Extend the log of the smarties.Array to this \n\t\tthis._log.extend(sArr._log);\n\n\t\treturn this;\n\t}\n\n\n\n\n\n\t/*\n\t* Shortcut to the underlying data\n\t*/\n\tRepeater.prototype.get=function get(key){\n\t\tif(this._private._data)\n\t\t\treturn this._private._data.get(key);\n\t\telse\n\t\t\treturn undefined;\n\t}\n\n\n\t/*\n\t* Shortcut to the underlying data\n\t*/\n\tRepeater.prototype.set=function set(key,value){\n\t\tif(this._private._data)\n\t\t\treturn this._private._data.set(key,value);\n\t\telse\n\t\t\treturn undefined;\n\n\t}\n\n\n\t/*\n\t* Get all nodes with instructions for this instance, based on if they have the targetClass set\n\t*\n\t* @opt <HTMLElement> parent \tOnly look for nodes in this parent. \n\t*\n\t* @return array[<HTMLElement>] \tThe $parent may be included\n\t*/\n\tRepeater.prototype.getNodesWithInstructions=function(parent){\n\t\tparent=parent||this._target\n\t\tcX.checkType('node',parent);\n\n\t\tvar nodes=Array.from(parent.getElementsByClassName(this._private.targetClass));\n\t\tif(parent && parent.classList.contains(this._private.targetClass)){\n\t\t\tnodes.push(parent);\n\t\t} \n\t\treturn nodes;\n\t}\n\n\n\n\t/*\n\t* Propogate all items on underlying smarties.Array to DOM\n\t*\n\t* NOTE: This function needs to be .call(this,...)\n\t*\n\t* @throws Error \tIf target is not empty\n\t* @return array \tArray of newly created nodes\n\t* @call(this)\n\t*/\n\tfunction addAll(){\n\t\tif(this._target.childElementCount){\n\t\t\tthis._log.throw(\"Target is not empty, cannot add items since it may create duplicates\",this._target);\n\t\t}\n\n\t\tif(this._data.length){\n\t\t\tthis._log.debug(`Going to add all ${this._data.length} items to target:`,this._target);\n\t\t\tvar nodes=this._data._private.data.map((value,key)=>insertItem.call(this,{value,key,src:'addAll'}));\n\t\t\t  //^since there was no 'event' we skip the key 'evt' and 'old'\n\t\t\tthis._log.trace(\"All items added\",nodes);\n\t\t\treturn nodes;\n\t\t}\n\t}\n\n\n\t/*\n\t* Add an item to the target\n\t*\n\t* @param object event\n\t*\n\t* @return node \t\tThe newly created clone\n\t* @call(this)\n\t*/\n\tfunction insertItem(event){\n\t\ttry{\t\t\n\t\t\t//Start by cloning and preparing a template\n\t\t\tvar clone=chooseAndCloneTemplate.call(this,event.key,event.value);\n\t\t\tvar childrenWithInstructions=prepareClone.call(this,clone);\n\t\t\tlet ble=this._log.makeEntry('debug',\"Prepared new repeat item:\")\n\t\t\t\t.addHandling('Children with instructions:',childrenWithInstructions)\n\n\t\t\t//Then fill the new clone with data\n\t\t\tpropogateToNodes.call(this,clone,event)\n\t\t\t\n\t\t\tble.addHandling('Data:',event).exec();\n\t\t}catch(err){\n\t\t\tvar clone=document.createElement('span');\n\t\t\tthis._log.error(\"Failed to get template. Substituting empty <span> to keep Repeater \"\n\t\t\t\t+\"in-sync with underlying data\",err,clone,event);\n\n\t\t\tclone._checkRightTemplate=function(){return false;} //never the right template, which forces the repeater to try again\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//when data changes\t\t\t\n\t\t}\n\n\t\tif(event.key==this.length){\n\t\t\tthis._target.appendChild(clone);\n\t\t}else{\n\t\t\tthis._target.insertBefore(clone, this._target.children[event.key]); //insert before the current child in that position\n\t\t}\n\n\t\tif(this._private.options.addGetters){\n\t\t\t//Regardless where the item was inserted, the total length has increased, so add a public getter\n\t\t\tlet last=this._target.childElementCount-1\n\t\t\t\t,self=this\n\t\t\t;\n\t\t\tObject.defineProperty(this,last,{\n\t\t\t\tenumerable:true,configurable:true,get:function getRepeaterItem(){return self._target.children[last];}});\n\t\t}\n\n\t\t\n\t\treturn clone;\n\t}\n\n\t/*\n\t* The following scenario used to create a bug:\n\t* \tCreate repeater A\n\t* \t\tCreate repeater B inside\n\t* \tDestroy repeater A\n\t* \tCreate repeater A\n\t* \t\tAttempt to create repeater B --> fail\n\t* \n\t* It may be because repeater B was not correctly destroyed, so this function checks if children are repeaters and \n\t* destroys them before destroying the parent\n\t*\n\t* @param element elem\n\t* @return elem \t\t\tSame as passed in\n\t*/\n\tfunction gracefullyRemoveElement(elem){\n\n\t\t//First we need to find and destroy any nested Repeater. We want to destroy the deepest one first...\n\t\tvar nodes=this.findNestedRepeaters(elem,true); //true=>only get setup children\n\t\t\n\t\tif(nodes.length){\t\t\n\t\t\tthis._log.debug(`Destroying ${nodes.length} nested repeaters before proceeding:`,nodes);\n\t\t\tnodes.forEach(node=>node._repeater.destroy());\n\t\t\tthis._log.debug(\"Done destroying children, now removing this elem:\",elem)\n\t\t}else{\n\t\t\tthis._log.debug(\"No nested repeaters found, just removing this elem:\",elem);\n\t\t}\n\n\t\t//Now we only have non-repeaters left. We may want to loop through them an delete each in turn in the\n\t\t//same way, but for now we're trying just to remove them all\n\t\tblackhole.adoptNode(elem);\n\t\treturn elem\n\t}\n\n\n\n\t/*\n\t* Remove all items from target, even those not created by this repeater\n\t*\n\t* NOTE: This function needs to be .call(this,...)\n\t*\n\t* @return void\n\t*/\n\tfunction emptyTarget(){\n\t\tvar total=this._target.childElementCount;\n\t\tthis._log.debug(`Emptying target of all ${total} elements:`,this._target);\n\n\t\tif(this.length<total)\n\t\t\tthis._log.warn(\"Additional elements in target detected, these will be removed as well\");\n\n\t\t//Remove all children\n\t\twhile(this._target.childElementCount){\n\t\t\t// this._target.removeChild(this._target.lastElementChild)\n\t\t\tgracefullyRemoveElement.call(this,this._target.lastElementChild); //2019-05-23: Trying to solve issue when re-adding nested repeaters\n\t\t}\n\n\t\t//Remove all public getters\n\t\tif(this._private.options.addGetters){\n\t\t\tvar p,d;\n\t\t\tfor(p of Object.getOwnPropertyNames(this)){\n\t\t\t\ttry{\n\t\t\t\t\td=Object.getOwnPropertyDescriptor(this,p);\n\t\t\t\t\tif(d.enumerable==true && typeof d.get=='function'){\n\t\t\t\t\t\tdelete this[p];\n\t\t\t\t\t}\n\t\t\t\t}catch(err){\n\t\t\t\t\tthis._log.error(\"Problems while deleting public getters. Current prop: \"+p,err,d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t/*\n\t* Remove all items from target, then add them back. Can be used if for some reason we're out of sync between\n\t* data and DOM items\n\t*\n\t* @return this\n\t*/\n\tRepeater.prototype.repopulateTarget=function(){\n\t\temptyTarget.call(this);\n\t\taddAll.call(this);\n\t\treturn this;\n\t}\n\n\n\n\t/*\n\t* Setup this repeater, ie. start propogating private data to DOM. Opposite of destroy() which removes all DOM data.\n\t* Think of these two methods as show and hide.\n\t*\n\t* NOTE: This method can be called multiple times if we call destroy() inbetween.\n\t* NOTE2: Template is only parsed on first call to this method\n\t*\n\t* @param \n\t*\n\t* @return this\n\t*/\n\tRepeater.prototype.setup=function(data){\n\t\t//If data was passed in, either setup a \n\t\t//Don't run twice\n\t\tif(!this.isSetup()){\n\t\t\tvar opt=this._private.options;\n\t\t\t// this._log.info(\"Setting up repeater with options: \",opt,this);\n\n\t\t\t//First, create/set smarties.Array on self._data. If nothing is passed in\n\t\t\t// a) we're already setup so nothing happens\n\t\t\t// b) an empty smarties.Array is setup\n\t\t\tthis.setupData(data)\n\n\n\n\t\t\t//On first call to setup(): parse/prepare the template. We do this after setting up data so we\n\t\t\t//can check what kind of children, and thus what kind of instructions we expect (bad instructions will be removed)\n\t\t\tif(!this._templates){\n\t\t\t\tObject.defineProperty(this,'_templates',{value:this.prepareTemplates()});\n\t\t\t}\n\n\n\t\t\t//On each setup make sure we have a live target in this document\n\t\t\tif(!this._target || this._target.ownerDocument!=document){\n\t\t\t\tlet target=prepareTarget.call(this);\n\t\t\t\tObject.defineProperty(this,'_target',{configurable:true,value:target});\n\t\t\t}\n\n\t\t\t//If any data already existed (or was setup here), propogate it to DOM before listening for events. We\n\t\t\t//do this both to limit log, but also for same handling of existed before/setup here\n\t\t\taddAll.call(this);\n\t\t\tthis._log.trace(\"Repeater should now be setup/visible\");\n\n\t\t\t//Listen to data change events on self and propogate them to the DOM. This listener is\n\t\t\t//what determines if the repeater has been setup or not.\n\t\t\tthis._data.on('event',this._private.dataEventCallback);\n\n\t\t//If new data is passed in, replace existing data which will propogate to DOM\n\t\t}else if(Array.isArray(data)){\n\t\t\tthis._log.trace(\"Setting up with new data, old/new:\",this._data.get(),data);\n\t\t\tthis.replace(data);\n\n\t\t}else{\n\t\t\tthis._log.warn(\"Repeater already setup, cannot do it again\",this);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\n\t/*\n\t* The opposite of 'setup()', remove all items from the DOM (but keep the data/smarties.Array). This can be reversed \n\t* again with 'setup()'\n\t*\n\t* @return this\n\t*/\n\tRepeater.prototype.destroy=function(force=false){\t\t\n\t\tif(force||this.isSetup()){\n\t\t\tthis._log.debug(`Going to stop listening to private data and empty target of elements.`,this);\n\n\t\t\t//Stop propogating changes to DOM\n\t\t\tthis._data.removeListener(this._private.dataEventCallback,'event');\n\n\t\t\t//Remove any items from target. NOTE this may remove more than our nodes if someone has put stuff in\n\t\t\t//the target... that's a fail-safe so we can always continue\n\t\t\temptyTarget.call(this);\n\n\t\t}else{\n\t\t\tthis._log.warn(\"Repeater not setup, nothing to destroy\",this);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\n\n\n\t/*\n\t* The function which .setup() will use to listen for the 'event' event on ._data. This func either moves\n\t* existing nodes around, or it creates new ones/alters existing ones\n\t*\n\t* NOTE: This func is bound to this instance by constructor and stored on ._private. That way each instance\n\t*\t\tgets a unique version of it that can be identified and removed when multiple Reapeaters share the\n\t*\t\tsame underlying SmartArray\n\t*\n\t* @emit new(i,elem,data)\n\t* @emit delete(i,oldElem,oldData)\n\t* @emit change(i,elem,data,oldData)\n\t* @emit move(elem,to,from) \t\n\t*\n\t* @return void\n\t* @no-throw\n\t* @bind(this)\n\t*/\n\tfunction dataEventCallback(event){\n\t\t// evt,i,value,old,oldIndex\n\t\ttry{\n\n\t\t\tthis._log.traceFunc(arguments);\n\n\t//TODO 2020-04-01: We're allowing complex values, but we can't handle nested keys here... so just\n\t//\t\t\t\t\tmake sure we havn't got one\n\t\t\tif(isNaN(Number(event.key))){\n\t\t\t\tthis._log.error(\"BUGBUG: Repeaters can't handle nested keys, we're only interested in \"\n\t\t\t\t\t+\"what happens with the local array\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t\t\n\t\t\tvar elem,indexesAffected\n\n\t\t\t//The 'new' event is the only where elem doesn't need to exist, so do that first...\n\t\t\tif(event.evt=='new'){\n\t\t\t\telem=insertItem.call(this,event)\n\t\t\t\t\n\t\t\t\t//Get effected range AFTER adding\n\t\t\t\tlet last=this.length-1;\n\t\t\t\tif(this._private.indexDependentPatterns && event.key<last){\n\t\t\t\t\tindexesAffected=cX.range(event.key+1,last);\n\t\t\t\t}\n\n\t\t\t}else{\n\t\t\t\telem=this._target.children[event.key]\n\t\t\t\t//...for all the rest it must, so check\n\t\t\t\tif(bu.varType(elem)!='node'){\n\t\t\t\t\tthis._log.error(\"Child #\"+event.key+\" does not exist, cannot propogate event: \"+evt);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tswitch(evt){\n\t\t\t\t\tcase 'indexChange':\n\t\t\t\t\t\t// This case is almost a copy of 'change'v\n\n\t\t\t\t\t\t//We use the .indexDependentPatterns prop to make sure we're not checking unecessarily \n\t\t\t\t\t\t//where we KNOW patterns don't contain '#'\n\t\t\t\t\t\tif(this._private.indexDependentPatterns!='i' && !elem._checkRightTemplate(value)){\n\t\t\t\t\t\t\tgracefullyRemoveElement.call(this,elem);\n\t\t\t\t\t\t\telem=insertItem.call(this,event);\n\t\t\t\t\t\t\tthis._log.debug(\"Changed templates for elem #\"+event.key,elem);\n\t\t\t\t\t\t}else if(this._private.indexDependentPatterns!='t' && elem.hasAttribute(TAG_RID)){\n\t\t\t\t\t\t\tpropogateToNodes.call(this,elem,event,'onlyIndexPatterns')\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tthis._log.trace(\"Ignoring elem without index dependent pattern.\",event,elem)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'change': \n\t\t\t\t\t\tif(!elem._checkRightTemplate(value)){\n\t\t\t\t\t\t\t// this._target.removeChild(elem);\t\t\n\t\t\t\t\t\t\tgracefullyRemoveElement.call(this,elem);\n\t\t\t\t\t\t\telem=insertItem.call(this,event);\n\t\t\t\t\t\t\tthis._log.debug(\"Changed templates for elem #\"+event.key,elem);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tpropogateToNodes.call(this,elem,event)\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// this.doubleEmit('nodeChange',elem,value,oldValue);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'delete':\n\t\t\t\t\t \tthis._log.debug('Removing repeater elem #'+event.key,elem);\n\n\t\t\t\t\t \t//Get effected range BEFORE deleting\n\t\t\t\t\t \tlet last=this.length-1;\n\t\t\t\t\t \tif(this._private.indexDependentPatterns && event.key<last){\n\t\t\t\t\t \t\tindexesAffected=cX.range(event.key,last);\n\t\t\t\t\t \t}\n\n\t\t\t\t\t\t// this._target.removeChild(elem);\t\n\t\t\t\t\t\tgracefullyRemoveElement.call(this,elem); //2019-05-23: Trying to solve issue when re-adding nested repeaters\n\n\t\t\t\t\t\tif(this._private.options.addGetters){\n\t\t\t\t\t\t\t//It just got one shorter, so remove the last getter\n\t\t\t\t\t\t\tdelete this[this.length];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'move':\n\t\t\t\t\t\tthis._log.debug('Moving repeater elem #'+event.from+\" to #\"+event.to,elem);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(this._private.indexDependentPatterns){\n\t\t\t\t\t\t\tindexesAffected=[Math.min(event.from,event.to),Math.max(event.from,event.to)];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._target.insertBefore(elem, this._target.children[event.to]);\n\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthis._log.note('Unhandled event: '+evt);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//If we affected any indexes...\n\t\t\tif(indexesAffected){\n\t\t\t\t// ...just call this same method again saying that index has changed. It's not the fastest way of doing it,\n\t\t\t\t//but at least it works\n\t\t//TODO 2020-04-01: Make sure this is correct...\n\t\t\t\tindexesAffected.forEach(key=>dataEventCallback.call(this,Object.assign({},event,{evt:'indexChange',key,old:event.value})))\n\t\t\t\t\t//^be clear that the old value hasn't changed\n\t\t\t}\n\n\t\t\t//Kindof propogate the event from the underlying smarty...\n\t\t\tevent.target=elem\n\t\t\tthis.emit(event);\n\t\t\t\n\t\t\n\t\t}catch(err){\n\t\t\tthis._log.error(\"BUGBUG\",err);\n\t\t}\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t/*\n\t* Find all nested repeaters in a given element (can be any element in the DOM)\n\t*\n\t* @param <HTMLelement>  elem \n\t* @param bool \t\t\tonlySetup  \tDefault false. If true only child repeaters that have been setup are counted\n\t*\n\t* @return array(<Node>,...) \tArray of nodes, each having a ._repeater property. The deepest one first\n\t*/\n\tRepeater.prototype.findNestedRepeaters=function(elem,onlySetup=false){\n\t\tbu.checkType('node',elem)\n\n\t\tvar\tnodes=Array.from(elem.querySelectorAll('[repeater-target]'));\n\n\t\tif(nodes.length){\n\t\t\t//We want to return an array organized by depth (so eg. gracefullyRemoveElement() can remove them \n\t\t\t//in the right order), so start by grouping them by such....\n\t\t\tvar byDepth={},c=0;\n\t\t\tnodes.forEach(node=>{\n\t\t\t\t//Optionally check if setup...\n\t\t\t\tif(onlySetup && !node._repeater.isSetup()){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tc++;\n\t\t\t\tlet d=bu.countParentNodes(node);\n\t\t\t\tif(byDepth.hasOwnProperty(d))\n\t\t\t\t\tbyDepth[d].push(node);\n\t\t\t\telse\n\t\t\t\t\tbyDepth[d]=Array(node);\n\t\t\t})\n\n\t\t\t//...then flatten into an array\n\t\t\tnodes=[];\n\t\t\tvar keys=Object.keys(byDepth).sort().reverse().forEach(key=>{\n\t\t\t\tnodes.push.apply(nodes,byDepth[key])\n\t\t\t})\n\t\t}\n\n\t\treturn nodes;\n\t}\n\n\tRepeater.prototype.countNestedItems=function(onlySetup=false){\n\t\tvar l=this.length,count=0;\n\t\tfor(var i=0;i<l;i++){\n\t\t\tthis.findNestedRepeaters(this[i],onlySetup).forEach(child=>count+=child.length);\n\t\t}\n\t\treturn count;\n\t}\n\n\n\tRepeater.prototype.replace=function(arr){\n\n\t\tif(!this.hasOwnProperty('_data')){\n\t\t\tthis._log.throw(\"Not data setup yet, cannot replace\");\n\t\t}\n\n\t\ttry{\n\t\t\t//Try replacing gracefully (ie. only apply changes...), but if anything goes wrong, stop trying right away\n\t\t\t//since the order is most likely messed up...\n\t\t\tvar oldValues=this._data.get();\n\t\t\tthis._data.replace(arr,'panic'); //panic==stop right away\n\t\t}catch(err){\n\t\t\tthis._log.warn(\"Regular delete->event->propogate failed. Manually emptying DOM target and data.\",err);\n\t\t\t//...and instead just replace everything\n\t\t\temptyTarget.call(this);\n\t\t\tthis._data._brutalEmpty(); //Just replace private data array with zero ado...\n\t\t\tthis._data.concat(arr);\n\t\t}\n\t\treturn oldValues;\n\t}\n\n\n\tRepeater.prototype.empty=function(){\n\t\treturn this.replace([]);\n\t}\n\n\n\n\n\n\n\t/*\n\t* Prepare target (ie. where copies of the template will be inserted)\n\t*\n\t* NOTE: This method removes the template if it exists inside the target\n\t* \n\t* @return <HTMLElement> \tThe live target element\n\t*\n\t* @call(this)\n\t*/\n\tfunction prepareTarget(){\n\t\tthis._log.traceFunc(arguments);\n\t\ttry{\n\t\t\tvar target,template;\n\n\t\t\tif(this._private.options.target){\n\t\t\t\t//If a specific target was specified in options, that takes presidence\n\t\t\t\ttarget = bu.getLiveElement(this._private.options.target,true); //true==return null if none found\n\t\t\t\tif(!target)\n\t\t\t\t\tthrow this._log.makeError(\"Bad target (arg#2)\",this._private.options.target);\n\t\t\t\telse\n\t\t\t\t\tthis._log.debug(\"Using explicit target:\",this._private.options.target)\n\t\t\t}else{\n\t\t\t\t//...else use the parent of the template\n\t\t\t\ttry{\n\t\t\t\t\ttemplate=bu.getLiveElement(this._private.options.template,false);//false==throw on not found\n\t\t\t\t\ttarget = template.parentNode \n\t\t\t\t\tthis._log.debug(\"Using templates' parent as target:\",target)\t\t\n\t\t\t\t}catch(err){\n\t\t\t\t\tthis._log.debug(\"No explicit target specified, trying templates' parent\");\n\t\t\t\t\tthrow err;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Now make sure it's valid...\n\t\t\tif(target.ownerDocument!=document)\n\t\t\t\tthis._log.throw(\"The target is not part of this document:\",target);\n\n\t\t\t//Remove the template if it was inside the target\n\t\t\tlet c=target.childElementCount;\n\t\t\tif(c>0){\n\t\t\t\tif(c>1||target.firstElementChild!=template)\n\t\t\t\t\tthis._log.throw(\"Repeater targets must be empty.\",{target,'liveTemplate':template,\n\t\t\t\t\t  'template':this._private.options.template,'Repeater':this});\n\t\t\t\ttarget.removeChild(template);\n\t\t\t}\n\t\t\t\n\t\t\t//...finally mark it with a flag which we use when checking for nested repeaters (and for debug clarity)\n\t\t\ttarget.setAttribute('repeater-target',this._private.targetClass);\n\t\t\ttarget._repeater=this;\n\n\t\t\t//...aaand set a ref on the node to this repeater (debug clarity only?)\n\t\t\t\n\n\t\t\treturn target;\n\n\t\t}catch(err){\n\t\t\tthis._log.throw(\"Failed to get target.\",err);\n\t\t}\n\t}\n\n\n\n\n\n\t/*\n\t* Prepare all elements in a template(s) so it can be quickly copied and values inserted into it.\n\t*\n\t* NOTE: This method should be run AFTER setupData() so we know what kind of pattern to expect\n\t* NOTE2: This method can't prepare everything since we're cloning, so also see prepareClone()\n\t*\n\t* @return array \t\tArray of templates (cloned nodes)\n\t*/\n\tRepeater.prototype.prepareTemplates = function(){\n\t\tvar template=bu.getLiveElement(this._private.options.template); //gets html node from node|id|htmlstring\n\t\t\n\t\t//Since multiple repeaters may be using the same template, we need our own copy, so clone it (or possibly them, see vv)\n\t\tvar clones;\n\t\tif(template.tagName=='TEMPLATE'){\n\t\t\t//The <template> tag is a DocumentFragment, which means we have to get it's children which are the actual \n\t\t\t//templates... children-->plural, which means there could be multiple templates...\n\t\t\t// clones=Array.from(template.content.children,child=>child.cloneNode(true));\n\t\t\tclones=Array.from(template.content.children,child=>document.importNode(child,true));//2019-02-08: adopt just in case...\n\n\t\t}else{\n\t\t\t// clones=[template.cloneNode(true)];\n\t\t\tclones=[document.importNode(template,true)]; //2019-02-08: true=>adopt...just in case...\n\t\t}\n\n\t\t\n\t\t//If we have multiple templates, we have to make sure they have ${'xxx-repeat'}-if attributes, since we'll \n\t\t//only be inserting a single template for each item in the underlying smarties.Array. So any that are missing \n\t\t//this attr, delete\n\t\tif(clones.length>1){\n\t\t\tfor(var i=clones.length-1;i>-1;i--){\n\t\t\t\tlet c=clones[i];\n\n\t\t\t\tif(!c.hasAttribute('xxx-repeat_usedefault')){\n\t\t\t\t\tlet attr='xxx-repeat_useif'\n\t\t\t\t\tif(!c.hasAttribute(attr)){\n\t\t\t\t\t\tthis._log.warn(`Removing one of multiple templates because it's missing useif/usedefault attributes:`,c); \n\t\t\t\t\t\tclones.splice(i,1);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tvar rule=c.getAttribute(attr);\n\t\t\t\t\t\trule=bu.tryJsonParse(rule, true) || [rule]; \n\t\t\t\t\n\t\t\t\t\t\t//if a single value was given ^, then it was the criteria, so we add pattern and operator\n\t\t\t\t\t\tif(rule.length==1){\n\t\t\t\t\t\t\trule.unshift('$','==');\n\t\t\t\t\t\t}else if(c.getAttribute(rule[0]).includes('#')){\n\t\t\t\t\t\t\tthis._private.indexDependentPatterns='t';  \n\n//TODO: keep seperate track if template-choice is '#'\n\t\t\t\t\t\t\tthis._log.warn(\"Slow template chooser:\",rule);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//now re-save the full rule\n\t\t\t\t\t\tc.setAttribute(attr,JSON.stringify(rule));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(clones.length>1){\t\n\t\t\tthis._log.info(`Multiple templates (${clones.length}) found:`,clones);\n\t\t}else{\n\t\t\tthis._log.debug('Single template found:',clones[0]);\n\t\t}\n\t\t\n\t\t//Now we want to do as much preparation as possible, so we don't have to do it each \n\t\t//time in createItem(). So loop through all templates...\n\t\tclones.forEach((clone,i)=>{\n\t\t\t//...and all nodes in each template\n\t\t\tvar allElems=Array.from(clone.getElementsByTagName(\"*\"));\n\t\t\tallElems.push(clone); //include the clone itself\n\t\t\tvar t=0\n\t\t\tallElems.forEach(elem=>{\n\t\t\t\ttry{\n\t\t\t\t\t//We need to remove ids, but for debug purposes we'd like to still be able to \n\t\t\t\t\t//see them, so move them to another attribute\n\t\t\t\t\tif(elem.hasAttribute('id')){\n\t\t\t\t\t\telem.setAttribute('_id',elem.getAttribute('id'));\n\t\t\t\t\t\telem.removeAttribute('id');\n\t\t\t\t\t}\n\n\t\t\t\t\t//Now look for any instructions\n\t\t\t\t\tvar instructions=getRepeatInstructions.call(this,elem);\n\n\t\t\t\t\t//Unlike Binder, Repeater clones nodes, which removes any props set on the live node,\n\t\t\t\t\t//which implies that we have to store the instructions as string attributes for now\n\t\t\t\t\t//and JSON.parse() them to live in prepareClone(). And for future dev.ref: we can't\n\t\t\t\t\t//convert them to live here and them copy them to the clone because we clone the entire\n\t\t\t\t\t//template, not each child individually... just think about it...\n\t\t\t\t\tif(instructions){\n\t\t\t\t\t\telem.setAttribute('xxxRepeat',JSON.stringify(instructions)); \n\t\t\t\t\t\tt+=instructions.length\n\n\t\t\t\t\t\t//If any instructions include '#', mark the entire clone/template\n\t\t\t\t\t\tif(!clone.hasAttribute(TAG_RID) && instructions.find(inst=>inst.pattern.includes('#'))){\n\t\t\t\t\t\t\tclone.setAttribute(TAG_RID,'');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\t\t\t\t}catch(err){\n\t\t\t\t\tthis._log.error(\"Failed to prepare template node.\",err,elem);\n\t\t\t\t}\n\t\t\t});\n\t\t\t//Unlike Binder/Nav, here we have templates with multiple children, any of which may have instructions\n\t\t\t//(but usually not all of them). So we send noWarn in getRepeatInstructions(), and now if none of them\n\t\t\t//had any instructions we warn here\n\t\t\tlet msg=`Prepared template ${i+1} of ${clones.length},`, attr=Repeater._baseAttr+'_noaction';\n\t\t\tif(t || clone.hasAttribute(attr))\n\t\t\t\tthis._log.debug(`${msg} it has ${t} instructions`);\n\t\t\telse\n\t\t\t\tthis._log.warn(`${msg} but it has no instructions! (if intentional please add attribute '${attr}'`)\n\n\t\t})\n\n\n\t\treturn clones;\n\t}\n\n\n\t/*\n\t* Since we're cloning nodes, and may be sharing templates, we can't do all the preparations in prepareTemplates(), \n\t* this function does the rest after cloning...\n\t*\n\t* @param <HTMLElement> clone \tA newly cloned template\n\t*\n\t* @return array \t\t\t\tArray of those child nodes that have instructions\n\t* @call(<Repeater>)\n\t*/\n\tfunction prepareClone(clone){\n\t\tdocument.adoptNode(clone); //2019-05-23: Trying to solve issue with not being able to find by id... //2020-02-10: ???\n\t\t\n\t\t//Set a few shortcuts and a flag on the clone to help out... _repeatIndex eg. is used by chooseAndCloneTemplate()\n\t\tclone.setAttribute('repeater-item',this._private.targetClass); \n\t\tObject.defineProperties(clone,{\n\t\t\t_repeater:{enumerable:true,get:()=>this}\n\t\t\t,_repeatIndex:{enumerable:true,get:()=>Array.from(clone.parentElement.children).indexOf(clone)}\n\t\t\t,_repeatData:{enumerable:true,get:()=>this._data.get(clone._repeatIndex)}\n\t\t})\n\n\t\t\n\t\t//Turn all pre-parsed instructions into live objects\n\t\tlet nodes=this.getNodesWithInstructions(clone)\n\t\tnodes.forEach(getRepeatInstructions.bind(this));\n\n\t\treturn nodes;\n\t}\n\n\n\t/*\n\t* Get instructions from an element\n\t*\n\t* @param <HTMLElement> elem\n\t*\n\t* @return array|undefined \t\tAn array of objects if instructions exist, else undefined\n\t* @call(<Repeater>)\n\t*/\n\tfunction getRepeatInstructions(elem){\n\t\t//If no live object exists on the elem...\n\t\tif(!elem.hasOwnProperty('xxxRepeat')){\n\t\t\t//...and no attribute either...\n\t\t\tif(!elem.hasAttribute('xxxRepeat')){\n\t\t\t\t//...then look for and parse new instructions, saving it to the prop we checked first ^^\n\t\t\t\tlet instructions=proto.getInstructions.call(this\n\t\t\t\t\t,elem\n\t\t\t\t\t,validateInstruction.bind(this) //callback used to determine we have a good pattern, throw => don't include\n\t\t\t\t\t,this._private.options.debugMode?'extract':''\n\t\t\t\t\t,'emptyOK' //don't warn if individual elems don't have instructions, see prepareTemplates() for details\n\t\t\t\t);\n\n\t\t\t\t//If we found any, save them, else at least make sure the prop exists so the the prop we checked first^...\n\t\t\t\telem.xxxRepeat=(instructions.length ? instructions : null)\n\n\t\t\t//If it does have the attribute (which will be the case with every new clone)...\n\t\t\t}else{\n\t\t\t\t//...just make it live and save it to the prop we checked first ^^...\n\t\t\t\telem.xxxRepeat=bu.getJsonAttr(node,'xxxRepeat');\n\n\t\t\t\t//The attr has now served it's purpose, the only reason to keep it is debugging\n\t\t\t\tif(!this._private.options.debugMode)\n\t\t\t\t\tnode.removeAttribute('xxxRepeat');\n\t\t\t}\n\n\t\t\t//If we found any instructions...\n\t\t\tif(elem.xxxRepeat){\n\t\t\t\t//...set this Repeater's targetClass on the elem to mark that it's got instructions\n\t\t\t\telem.classList.add(this._private.targetClass); \n\n\t\t\t\t//ProTip: If you need to change the instructions on a single element you should delete both prop and \n\t\t\t\t//\t\t  attr \"xxxRepeat\", but leave this class/flag. That way the next time propogateToNodes() is \n\t\t\t\t//\t\t  called it'll find this elem but will be forced to look for new instructions\n\t\t\t}\n\t\t}\n\n\t\t//Now return what may be instructions, or may be undefined\n\t\treturn elem.xxxRepeat;\n\t}\n\n\n\n\n\t/*\n\t* Check that an instruction is valid for a Repeater. This mostly deals with the pattern...\n\t*\n\t* @param object inst  \t\t\t\tInstructions found on a node, parsed into a live object\n\t*  @prop string|array key|pattern \tArrays will be converted: [\"person\",\"age\"] => \"${person.age}\"\n\t*\n\t* @throw <TypeError>  \t\tIf pattern isn't string\n\t* @throw <ble EMISMATCH> \tIf complex pattern but this Repeater can only handle primitive children\n\t*\n\t* @return void \t\t\t\n\t*\n\t* @call(this) \t\t\n\t*/\n\tfunction validateInstruction(inst){\n\n\t\t//For Repeater the key is a pattern, so rename it\n\t\tinst.pattern=inst.key\n\t\tdelete inst.key;\n\n\t\t//Make sure it's a string, but an array kan be used to signify a netsted get\n\t\tswitch(typeof inst.pattern){\n\t\t\tcase 'string':\n\t\t\t\tif(inst.pattern.includes('#')){\n\t\t\t\t\t//This will slow things down if we re-order the array often\n\t\t\t\t\tthis._private.indexDependentPatterns='i';\n\t\t\t\t\tthis._log.warn(\"Slow instruction:\",inst);\n\t\t\t\t}else if(!inst.pattern.includes('$')){\n\t\t\t\t\t//If there is no special character we assume it's the name of a single prop\n\t\t\t\t\tinst.pattern='${'+inst.pattern+'}';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'object': //really means it's an array, because getInstructions() has already made sure it's a string|number|array\n\t\t\t\tinst.pattern='${'+inst.pattern.join('.')+'}';\n\t\t\t\tbreak;\n\t\t\tcase 'number':\n\t\t\t\tthis._log.makeError(\"Repeater key/pattern cannot be numbers:\",inst.pattern).throw('TypeError');\n\t\t\t\tbreak;\n\t\t}\n\n\t\t//If we only deal in primitive children, then the pattern can't make reference to any props\n\t\tif(this._data._private.options.children=='primitive' && inst.pattern.match(/\\$\\{([^}]+)\\}/))\n\t\t\tthis._log.makeError(`options.children=='primitive' => no complex patterns: '${inst.pattern}'`).throw('EMISMATCH');\n\t\t //^the opposite can obviously happen, childen=='complex' but a specific child is primitive...\n\n\t\t\n\t\treturn;\n\t}\n\n\n\n\n\n\n\n\t/*\n\t* If multiple templates exist, they have rules when to use them, this method checks those rules\n\t*\n\t* @param number index \tIndex that $node is at or will be at\n\t* @param any value \t\tThe \n\t* @param array arr \t\tArray with 2 or 4 items: [template,criteria] or [template,pattern,operator,criteria]\n\t* @param any value \t\tThe value of an item in the _data\n\t*\n\t* @return bool \t\t\tTrue if the template should be used, else false\n\t* @no-throw\n\t* @call(this)\n\t*/\n\tfunction checkTemplateRule(index,value,rule,nodeToLog){\n\n\t\ttry{\n\t\t\tvar pattern=rule[0]\n\t\t\t\t,resolved=Repeater.applyPattern.call(this,index,value,pattern,nodeToLog) //can throw, usually if pattern type!=value type\n\t\t\t\t,operator=rule[1]\n\t\t\t\t,criteria=rule[2]\n\t\t\t;\n\t\t\treturn bu.compare.call(this,resolved,operator,criteria);\n\t\t}catch(err){\n\t\t\tthis._log.error(err);\n\t\t\treturn false;\n\t\t}\n\n\n\t}\n\n\n\n\n\t/*\n\t* Choose which template to used based on the value of an item\n\t*\n\t* @param number insertAt\t\tThe index the template is going to be inserted at\n\t* @param mixed value \t\tThe value of an item of the underlying smarties.Array\n\t*\n\t* @throws\n\t* @return node \t\t\tA cloned template, ready to be modified and inserted\n\t* @call(this)\n\t*/\n\tfunction chooseAndCloneTemplate(insertAt,value){\n\n\t\t//First we clone the template... but there may be multiple, in which case we have to figure out which one...\n\t\tif(this._templates.length>1){\n\t\t\t\n\t\t\tvar dflt,rules=[];\n\t\t\tfor(var i=0;i<this._templates.length; i++){\n\t\t\t\tvar t=this._templates[i];\n\t\t\t\tif(t.hasAttribute('xxx-repeat_usedefault')){\n\t\t\t\t\tdflt=t;\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\t//Get the rule which we've already made sure is an array like [pattern,operator,criteria]\n\t\t\t\tvar rule=bu.getJsonAttr(t,'xxx-repeat_useif');\n\n\t\t\t\t//store so we can check all rules later if default template is chosen this time\n\t\t\t\trules.push(rule); \n\t\t\t\t\n\t\t\t\t//Now check the rule\n\t\t\t\tif(checkTemplateRule.call(this,insertAt,value,rule,t)){\n\t\t\t\t\tvar clone=t.cloneNode(true);\n\t\t\t\t\tthis._log.debug(\"Rule matched, cloned template:\",checkedRule,clone);\n\t\t\t\t\n\t\t\t\t\t//Define func to check if a new value would still choose this template\n\t\t\t\t\tclone._checkRightTemplate=(newValue)=>checkTemplateRule.call(this,clone._repeatIndex,newValue,rule,clone)\n\n\t\t\t\t\treturn clone;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!dflt)\n\t\t\t\tthis._log.throw(\"None of the templates matched this value (and there's no default):\",value,rules);\t\n\t\t\t\n\t\t\tvar clone=dflt.cloneNode(true);\t\n\t\t\tthis._log.debug(\"No rule matched, using default:\",clone,{value,rules});\n\t\t\t\n\t\t\t//Define func to check that a new value would not choose any of the other templates, ie. default is \n\t\t\t//still right choice\n\t\t\tclone._checkRightTemplate=(newValue)=>{\n\t\t\t\tlet index=clone._repeatIndex;\n\t\t\t\tfor(var i=0;i<rules.length;i++){\n\t\t\t\t\tif(checkTemplateRule.call(this,index,newValue,rules[i],clone))\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn clone;\n\n\t\t}else{\n\t\t\tvar clone=this._templates[0].cloneNode(true);  \n\t\t\tthis._log.debug('Only one template existed, cloned that:',clone);\n\t\t\t\n\t\t\tclone._checkRightTemplate=function(){return true;} //Only one option, always the right value\n\t\t\t\n\t\t\treturn clone;\n\t\t}\n\t}\n\n\n\n\n\n\n\n\t\n\n\t/*\n\t* Propogate a value the DOM\n\t*\n\t* @param <HTMLElement> clone \t\t@see getNodeArray(clone)\n\t* @param object event \t\n\t* @param boolean onlyIndexPatterns \tIf truthy, only run instructions that contain '#'\n\t*\n\t* @return void\n\t* @call(this)\n\t*/\n\tfunction propogateToNodes(clone, event,onlyIndexPatterns=false){\n\t\tif(!event || typeof event!='object'||!event.hasOwnProperty('value')){\n\t\t\tthis._log.makeError(\"Bad data. Could not propogate to repeater item.\",{item:clone,data:event}).addFrom().exec();\n\t\t\treturn;\n\t\t}\n\t\tthis._log.traceFunc(arguments);\n\n\t\t//Loop through all child nodes with instructions (defined as those marked with this._private.targetClass)\n\t\tvar nodes=this.getNodesWithInstructions(clone), node, inst;\n\t\tfor(node of nodes){\n\t\t\tif(!Array.isArray(node.xxxRepeat)||!node.xxxRepeat.length){\n\t\t\t\tthis._log.error('BUGBUG No instructions on node:',node);\n\t\t\t}else{\n\t\t\t\t//If a pattern exists, apply it\n\t\t\t\t//...then loop throught the instructions and apply\n\t\t\t\tfor(inst of node.xxxRepeat){\n\t\t\t\t\t\n\t\t\t\t\t//If this is an index change, don't run any instructions that aren't index dependent...\n\t\t\t\t\tif(onlyIndexPatterns && !event.pattern.includes('#'))\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tthis.executeAction(node,inst,event);\t //should not throw\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\treturn;\n\n\t}\n\n\n\n\n\treturn Repeater;\n}//correct, we do NOT run this function here, see ./require_all.js\n//simpleSourceMap=\n//simpleSourceMap2=\n\n\n\n\n\n\n\n\n\n\n\t// /*\n\t// * Apply a pattern to a complex or primitie value, getting a string in return\n\t// *\n\t// * @param string pattern\n\t// * @param primitive|mixed value \tIf this.options.children=='primitive' => primitive, else this can be anyhing\n\t// * @opt <HTMLElement> node \t\tFor logging purposes only!\n\t// *\n\t// * @throw <ble TypeError> If $pattern isn't string (prepareTemplates() should have ensured we get string \n\t// *\t\t\t\t\t\t\tso this doesn't happen)\n\t// * @throw <ble Error> \t If pattern type and value type mismatch\n\t// * @return string\n\t// */\n\t// Repeater.prototype.applyPattern=function(pattern,value,node=undefined){\n\t// \t//First handle the 3 most simple cases\n\t// \tif(pattern=='#')\n\t// \t//Determine which syntax to use...\n\t// \tif(determinePatternType(pattern)=='complex'){\n\t// \t\tif(typeof value=='object' || !value){//All complex or falsey values\n\t// \t\t\treturn applyComplexPattern.call(this,pattern,value,node);\n\n\t// \t\t}else{\n\t// \t\t\tthis._log.makeError(\"Got complex pattern but primitive value:\",{pattern,value,node}).throw();\n\t// \t\t}\n\n\t// \t}else{//pattern in primitive\n\t// \t\tif(value && typeof value=='object'){\n\t// \t\t\t//All non-primitives, excluding null\n\t// \t\t\tthis._log.makeError(\"Got primitive pattern but complex value:\",{pattern,value,node}).throw();\n\t// \t\t}else{\n\t// \t\t\tthis._log.trace(\"Resolving primitive pattern:\",{pattern,value,node});\n\t// \t\t\tif(value==undefined || value==null){\n\t// \t\t\t\treturn pattern.replace('#','');\n\t// \t\t\t}else{\n\t// \t\t\t\t//All primitive values\n\t// \t\t\t\treturn pattern.replace('#',value);\n\t// \t\t\t}\n\t// \t\t}\n\n\t// \t}\n\n\n\t// }\n\n\n\t// /*\n\t// * Broken out from applyPattern() to make code less condense. But only call it from there...\n\t// *\n\t// *\t\n\t// * @opt <HTMLElement> node \t\t\tFor logging purposes only!\n\t// *\n\t// * @return string \n\t// * @call(this) \t\tfor logging\n\t// */\n\t// function applyComplexPattern(pattern, value, node){\n\n\t// \tvar resolved=pattern; //init\n\t\t\n\t// \t//Find all the matching patterns...\n\t// \tvar regexp=/\\$\\{([^}]+)\\}/g\n\t// \t\t,matches=bu.regexpAll(regexp,pattern)\n\t// \t\t,logMsg\n\t// \t\t,lvl='trace'\n\t// \t;\n\n\t// \tif(value){\n\t// \t\t// var self=this;\n\t// \t\tvar noMatchedKeys=true;\n\t// \t\tmatches.forEach(function resolveEachPatternMatch(arr){\n\t// \t\t\t//...and swap them for the value of the corresponding key\n\t// \t\t\tif(value.hasOwnProperty(arr[1])){\n\t// \t\t\t\tnoMatchedKeys=false\n\t// \t\t\t\tresolved=resolved.replace(arr[0],value[arr[1]]);\n\t// \t\t\t}else{\n\t// \t\t\t\tresolved=resolved.replace(arr[0],'');\n\t// \t\t\t}\t\t\t\t\n\t// \t\t})\n\t// \t\tlogMsg=\"Resolved complex pattern.\";\n\t// \t\tif(noMatchedKeys){\n\t// \t\t\tlvl='warn';\n\t// \t\t\tlogMsg+=' No keys matched!'\n\t// \t\t}\n\n\t// \t}else{\n\t// \t\tmatches.forEach(function removeEachPatternMatch(arr){\n\t// \t\t\tresolved=resolved.replace(arr[0],'');\n\t// \t\t})\n\t// \t\tlogMsg=\"Empty value passed in, removed all matches from pattern.\";\n\t// \t\tlvl='info'\n\t// \t}\n\t\t\n\t// \t//Make sure \"true\"=>true etc.\n\t// \tresolved=bu.stringToPrimitive(resolved);\n\n\t// \tif(!resolved){\n\t// \t\tlogMsg+=' Resulting string is empty!'\n\t// \t\tlvl=(lvl=='warn'?lvl:'note');\n\t// \t}\n\n\t// \t//If we're testing templates to see which one to use, always log debug since most\n\t// \t//of them are expected to produce empty strings\n\t// \tif(node && !document.contains(node)){\n\t// \t\tlvl='debug'\n\t// \t}\n\n\t// \tthis._log[lvl](logMsg, node,{'object':value,pattern,regexp,matches,resolved});\n\t\n\t// \treturn resolved;\n\t// }\n\n\n//# sourceURL=webpack:///./src/xxx-repeat.class.js?");

/***/ }),

/***/ "./src/xxx.proto.js":
/*!**************************!*\
  !*** ./src/xxx.proto.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("//simpleSourceMap=/my_modules/xxx/xxx.proto.js\n//simpleSourceMap2=/lib/xxx/xxx.proto.js\n;'use strict';\n/*\n* @component Prototype\n* @part-of xxx-framework\n* @author plundell\n* @license Apache-2.0\n* @description This is the main file of the frontend xxx-framework. It requires the other components and produces an\n*              object containing their constructors: Binder, Navigator, Repeater.\n* @depends libbetter\n* @depends smarties\n* @exports function   This framework exports an \"exporter function\" which should be called with the \n*                     dependencies to get the \"real exported contents\". \n*/\n\n\nmodule.exports=function exportXXX(dep){\n\n\t//The passed in object should contain all the dependencies.\n\tfunction missingDependency(which){throw new Error(\"xxx-framework was initialized without/before a required dependency: \"+which);}\n\tif(!dep.BetterUtil) missingDependency('BetterUtil');\n\tif(!dep.BetterLog) missingDependency('BetterLog');\n\tif(!dep.BetterEvents) missingDependency('BetterEvents');\n\tif(!dep.Smarties) missingDependency('Smarties');\n\n\n\tconst bu = dep.BetterUtil\n\n\n\t//Is populated and returned/exported at bottom\n\tvar _export={};\n\t\n\n\t//Create a static log for all static functions to use\n\tvar xxxLog=new dep.BetterLog('xxx-framework');\n\n\n\t/*\n\t* Get an instance of BetterLog when we're not sure what context something is being called in\n\t* @opt object self\n\t* @return <BetterLog>\n\t* @proto\n\t*/\n\tfunction getLog(...alts){\n\t\tlet log=alts.find(self=>{\n\t\t\tif(self){\n\t\t\t\tif(self._isBetterLog)\n\t\t\t\t\treturn self;\n\t\t\t\telse if(self.log && self.log._isBetterLog)\n\t\t\t\t\treturn self.log;\n\t\t\t\telse if(self._log && self._log._isBetterLog)\n\t\t\t\t\treturn self._log\n\t\t\t}\n\t\t})\n\t\treturn xxxLog;\n\t}\n\n\n\t//Create the css rule we use to hide nodes\n\ttry{\n\t\tlet rule=bu.createCSSRule('.xxx-hide','display:none !important');\n\t\txxxLog.info(\"Created CSS rule for class 'xxx-hide', used by the xxx framework to hide elements.\",rule);\n\t}catch(err){\n\t\txxxLog.error(\"Failed to create css rule to hide elements. Hiding elements with this framework WILL NOT WORK NOW.\",err);\n\t}\n\t\n\n\n\n\n\t/*\n\t* Read instructions from attributes on a node. \n\t*\n\t* @param <HTLMElement> \tnode \t\tA live node to get instructions from\n\t* @opt <BetterLog> \t\tlog \t\tWill log info or warn if instructions where/not found\n\t* @opt function \t\tcb \t\t\tEach instruction is called with this. It can alter the instruction. If it returns 'drop'\n\t*\t\t\t\t\t\t\t\t\t the instruction will be dropped silently, if it throws it will be dropped with an err log\n\t* @opt @flag \t\t\t'extract' \tThe attributes will be removed from the node\n\t* @opt @flag \t\t\t'emptyOK' \tWill prevent warnings when no instructions where found\n\t* @opt @flag \t\t\t'group' \tGroups instructions by key, returning an object of arrays\n\t*\n\t* NOTE: we also look for sub-attributes of format \"$baseAttr-foo\" where foo will be used as the \"fn\" prop on returned inst\n\t* NOTE2: sub-attribute values that are not full json objects will be used as the \"key\" prop on returned inst\n\t*\n\t* @throw <TypeError> \tIf arg#1 or arg#2 is wrong type\n\t*\n\t* @return array[obj]|obj[arr[obj]] \t\tAn array of instruction objects (can be empty if none exists), or @see $group\n\t*\n\t* @call(xxx instance) \tFor logging + this.constructor._baseAttr\n\t*/\n\tfunction getInstructions(node,...optional){\n\t\tbu.checkType('node',node);\n\t\tconst log=getLog(this);\n\t\ttry{\n\t\t\t//Initiate array that will be returned (unless 'group' is passed vv)\n\t\t\tvar instructions=[];\n\n\t\t\tvar baseAttr=this.constructor._baseAttr;\n\t\t\tvar cb=bu.getFirstOfType(optional, 'function');\n\t\t\tvar extract=optional.includes('extract');\n\t\t\tvar group=optional.includes('group');\n\t\t\tvar emptyOK=optional.includes('emptyOK'); //Since individual nodes in eg. templates with multiple children\n\t\t\t\t\t\t\t\t\t\t\t\t\t//may not have instructions, one may want to NOT warn\n\n\t\t\t/*\n\t\t\t* Adds each instruction to the overall return array\n\t\t\t* @param object inst\n\t\t\t* @return void\n\t\t\t* @no_throw\n\t\t\t*/\n\t\t\tvar addInstruction=(inst)=>{\n\t\t\t\t//Use the global key if none is specified (ie. the key used for all instructions for the node, see vv)\n\t\t\t\tinst.key=inst.key||globalKey;\n\n\t\t\t\tlet t=bu.checkProps(inst,{\n\t\t\t\t\tfn:'string'\n\t\t\t\t\t,key:['number','string','array']\n\t\t\t\t\t,args:['array','primitive','undefined']\n\t\t\t\t\t,arg:['primitive','undefined'] //only used if args==undefined. the resulting prop will still be args=[...]\n\t\t\t\t\t,test:['array','primitive','undefined']\n\t\t\t\t});\n\t\t\t\t//REMEMBER: ALL keys on the inst obj are passed to the action function, BUT, also remember\n\t\t\t\t//that props on the 'event' object supersede them, and the prop 'node' will be set to the\n\t\t\t\t//node being acted upon\n\t\t\t\t\n\t\t\t\t//All functions are lower case, but they can be written however just to make it more legible\n\t\t\t\tinst.fn==inst.fn.toLowerCase();\n\t\t\t\t\n\n\t\t\t\t//Args should be an array (if nothing else an empty one)...\n\t\t\t\tif(t.args=='primitive')\n\t\t\t\t\tinst.args=[inst.args]\n\t\t\t\telse if(t.args=='undefined'){\n\t\t\t\t\tif(t.arg=='primitive')\n\t\t\t\t\t\tinst.args=[inst.arg];\n\t\t\t\t\telse\n\t\t\t\t\t\tinst.args=[];\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\t//If testing is desired, prepare that array. It will be used by executeAction() to check the value\n\t\t\t\tif(t.test!='undefined'){\n\t\t\t\t\tif(t.test=='primitive'){\n\t\t\t\t\t\tinst.test=bu.compare.splitOnOperator(inst.test) //may leave inst.test[0] == undefined, see vv\n\t\t\t\t\t}else if(t.test=='array'){\n\t\t\t\t\t\tif(inst.test.length==1){\n\t\t\t\t\t\t\tinst.test=bu.compare.splitOnOperator(inst.test[0]) //may leave inst.test[0] == undefined, see vv\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t//Make sure the array starts with an operator\n\t\t\t\t\t\t\tlet i=inst.test.findIndex(bu.compare.isOperator)\n\t\t\t\t\t\t\tif(i==-1) throw new Error('No compare operator found');\n\t\t\t\t\t\t\tif(i!=0) inst.test.unshift(t.test.splice(i,1)); //move to front\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!inst.test[0])\n\t\t\t\t\t\tinst.test[0]='===' //compare() would do this anyway, but the logstr would miss it\n\t\t\t\t}\n\n\n\t\t\t\t//Before adding it, call the optional callback. I\n\t\t\t\tif(cb && cb(inst)=='drop'){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tinstructions.push(inst);\n\t\t\t}\n\t\t\tvar badInst=(str,attr,node,err)=>{\n\t\t\t\tnode.setAttribute(attr+'_fail',str);\n\t\t\t\tnode.removeAttribute(attr);\n\t\t\t\tlog.error(`Bad ${attr} instructions on node:`,node,err);\n\t\t\t}\n\n\t\t\t//There are 3 ways/places we can find instructions:\n\t\t\t\t//1. A \"global attribute\" that defines the key for all other instructions. NOTE the use of '_' \n\t\t\t\t//   instead of '-'\n\t\t\t\tvar globalKey=bu.tryJsonParse(node.getAttribute(baseAttr+'_key'));\n\n\t\t\t\t//2. As a json obj/arr on the $baseAttr (this is necessary in case we want to use the same\n\t\t\t\t//   action multiple times, like setting multiple attributes)\n\t\t\t\tvar str=node.getAttribute(baseAttr);\n\t\t\t\t// console.log(baseAttr,node,str);\n\t\t\t\tif(str){\n\t\t\t\t\ttry{\n\t\t\t\t\t\tlet singleOrMultiple=JSON.parse(str);\n\t\t\t\t\t\tif(bu.checkType(['array','object'],singleOrMultiple)=='object'){\n\t\t\t\t\t\t\taddInstruction(singleOrMultiple)\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t//TODO 2020-02-05: Don't fail all just because one instruction is bad...\n\t\t\t\t\t\t\tsingleOrMultiple.forEach(addInstruction)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(extract)\n\t\t\t\t\t\t\tnode.removeAttribute(baseAttr);\t\n\n\t\t\t\t\t}catch(err){\n\t\t\t\t\t\tbadInst(str,baseAttr,node,err)\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t//3. On sub-attributes of format '$baseAttr-fn'\n\t\t\t\tvar obj=bu.getSubAttributes(node, baseAttr+'-',extract);\n\t\t\t\tfor(let fn in obj){\n\t\t\t\t\t// console.log(baseAttr+'-'+fn,obj[fn],node);\n\t\t\t\t\ttry{\n\t\t\t\t\t\tif(fn.includes('_fail'))\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t//obj[fn] should be a primitive or undefined here, not empty string...\n\n\t\t\t\t\t\tlet x=bu.tryJsonParse(obj[fn]);\n\t\t\t\t\t\tif(bu.varType(x)=='object'){\n\t\t\t\t\t\t\t//x is an entire inst object with key and args\n\t\t\t\t\t\t\tx.fn=fn;\n\t\t\t\t\t\t\taddInstruction(x);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tlet last=bu._log.last();\n\t\t\t\t\t\t\t  //^yes, it should be bu._log, we're checking the log used by bu.tryJsonParse()\n\t\t\t\t\t\t\tif(last && last.msg.includes('poorly formated JSON string')){\n\t\t\t\t\t\t\t\tlast.throw();\n\t\t\t\t\t\t\t}else if(globalKey){\n\t\t\t\t\t\t\t\t//since we already have a global key, x can be a single arg or \n\t\t\t\t\t\t\t\t//an array of args or undefined\n\t\t\t\t\t\t\t\taddInstruction({'args':x,'fn':fn}); \n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t//since we need a key, x has to be a single key or an array of \n\t\t\t\t\t\t\t\t//keys (push() will type check)\n\t\t\t\t\t\t\t\taddInstruction({'key':x,'fn':fn});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} \n\t\t\t\t\t}catch(err){\n\t\t\t\t\t\tbadInst(obj[fn],baseAttr+'-'+fn,node,err)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\n\t\t\tif(!bu.isEmpty(instructions)){\n\t\t\t\tlog.debug(`Found ${baseAttr} instructions on node: `,node,instructions);\n\t\t\t}else if(!emptyOK && !node.hasAttribute(baseAttr+'_noaction')){\n\t\t\t\t//If the node is expected to have instructions, warn that it doesn't\n\t\t\t\tlog.warn(`Node doesn't have ${baseAttr} instructions: `,node); \n\t\t\t}\n\n\t\t}catch(e){\n\t\t\tlog.error(\"BUGBUG\",e).addHandling('arguments:',arguments);\t\n\t\t}\n\t\t\n\t\t//Turn into object if opted... Do this after try/catch so we're ensured to return an object if expected\n\t\tif(group){\n\t\t\tinstructions=groupByKey(instructions); //doesn't throw, always returns object\n\t\t}\n\n\t\treturn instructions;\n\t}\n\n\n\n\t/*\n\t* @param array instructions \tArray of instruction objects, eg. \n\t*\t\t\t\t\t\t\t\t\t[{key:a, fn:show}, {key:a, fn:text},{key:b, fn:click}]\n\t*\n\t* @return object \t\t\t\tKeys are keys, values are nested arrays like $instructions but all with same key\n\t*\t\t\t\t\t\t\t\t\t{a:[{key:a, fn:show}, {key:a, fn:text}],b:[{key:b, fn:click}]}\n\t*/\n\tfunction groupByKey(instructions){\n\t\ttry{\t\n\t\t\tvar obj={};\n\t\t\tinstructions.forEach(inst=>{\n\t\t\t\tif(Array.isArray(inst.key)){\n\t\t\t\t\tinst.key.forEach(key=>bu.pushToNestedArray(obj,key,inst)); //ie. the same instruction can be added to multiple arrays\n\t\t\t\t}else{\n\t\t\t\t\tbu.pushToNestedArray(obj,inst.key,inst);\t\n\t\t\t\t}\n\t\t\t})\n\n\t\t\t//Add a few func for convenience\n\t\t\tObject.defineProperty(obj,'keys',{value:function keys(){return Object.keys(obj)}})\n\t\t\tObject.defineProperty(obj,'values',{value:function values(){return instructions}})\n\t\t\tObject.defineProperty(obj,'length',{get:()=>instructions.length})\n\n\t\t}catch(e){\n\t\t\tgetLog(this).error(\"BUGBUG\",e).addHandling('arguments:',arguments);\t\n\t\t}\n\t\treturn obj;\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\t/*\n\t* Show or hide a node if a condition evaluates to true, else do the opposite\n\t*\n\t* @param boolean \t\tshowOnTruthy\n\t* @param object \t\tx  \t\t\t\tAn object containing the following:\n\t*   @prop elem \t\t\tnode \t\t\t  The node to operate on\n\t*   @prop any \t\t \tvalue \t\t\t  The new value of the prop on the xxx instance. Used to determine hide/show, see @showIf\n\t* \t@opt array \t\t\ttest  \t\t\t  @see test2()\n\t*\n\t* @return void\n\t* @call(xxx instance) \tfor logging purposes\n\t*/\n\tfunction setDisplay(showOnTruthy, x){\n\t\tvar c=test2.call(this,x);\n\t\tif(c.test==showOnTruthy){\n\t\t\tthis._log.trace('Showing node:',x.node,c.logstr);\n\t\t\tshowElement(x.node);\n\t\t}else{\n\t\t\tthis._log.trace('Hiding node:',x.node,c.logstr);\n\t\t\thideElement(x.node);\n\t\t}\n\t\treturn;\n\t}\n\n\n\n\n\n\t/*\n\t* Hide an elem in the DOM. Always works and remembers last display\n\t*\n\t* @param mixed node \t@see bu.getLiveElement\n\t*\n\t* @return void\n\t* @static \t\t set on proto.static\t\n\t*/\n\tfunction hideElement(node){\n\t\tnode=bu.getLiveElement(node);\n\n\t\t//Always add our hide-class\n\t\tnode.classList.add('xxx-hide');\n\n\t\t//Then make sure it's hiding (and save any display value set on the element which can be\n\t\t//restored by showElement later)\n\t\tbu.hideElement(node);\n\n\t\treturn;\n\n\t}\n\n\n\t/*\n\t* Show a hidden elem in the DOM. Always works and restores previous display if available\n\t*\n\t* @param mixed node \t@see bu.getLiveElement\n\t*\n\t* @return void\n\t* @static \t\t set on proto.static\t\n\t*/\n\tfunction showElement(node){\n\t\tnode=bu.getLiveElement(node);\n\n\t\t//Always remove our class\n\t\tnode.classList.remove('xxx-hide');\n\n\t\t//Then make sure it's showing \n\t\tbu.showElement(node); //will have no effect if already showing\n\n\t}\n\n\n\n\t/*\n\t* Add a class and remove another\n\t*\n\t* @param object \t\tx  \t\t  An object containing the following:\n\t*   @prop elem \t\t\t\tnode \tThe node to operate on\n\t*   @prop any \t\t \t\tvalue \tNew class to add\n\t*   @prop string|undefined \told \tOld class to remove\t\n\n\t*\n\t* @return void\n\t* @call(xxx instance) \tfor logging purposes\n\t*/\n\tfunction followClass(x){\n\t\t// this._log.traceFunc(arguments);\n\t\tvar bug=\"BUGBUG: followClass() was called with the string 'undefined', probably a mistake.\"\n\t\tvar logStr='';\n\t\tif(x.old && typeof x.old=='string'){\n\t\t\tif(x.old=='undefined'){\n\t\t\t\tthis._log.warn(bug,arguments);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlogStr+=`Removing class '${x.old}'`\n\t\t\tx.node.classList.remove(x.old);\n\t\t}\n\n\t\tif(typeof x.value=='string'){\n\t\t\tif(x.value=='undefined'){\n\t\t\t\tthis._log.warn(bug,arguments);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlogStr+=(logStr?' and a':'A')+`dding class '${x.value}'`\n\t\t\tx.node.classList.add(x.value)\n\t\t}\n\t\tif(!logStr)\n\t\t\tthis._log.warn(\"Something went wrong. Class has probably NOT been updated. \\narguments:\",arguments);\n\t\telse\n\t\t\tthis._log.trace(logStr,x.node);\n\n\t\tif(x.node.classList && !x.node.classList.length)\n\t\t\tx.node.removeAttribute('class');\n\t}\n\n\n\n\t/*\n\t* Add/remove a class given a value and condition\n\t*\n\t* @param object \t\tx  \t\t\t\tAn object containing the following:\n\t*   @prop elem \t\t\tnode \t\t\t  The node to operate on\n\t*   @prop any \t\t \tvalue \t\t\t  The new value of the prop on the xxx instance. Used to determine if we're setting or removing $cls\n\t* \t@prop string \t\targs|arg|cls \t  The class to set\n\t* \t@opt array \t\t\ttest  \t\t\t  @see test2()\n\t*\n\t* @return void\n\t* @call(xxx instance) \tfor logging purposes\n\t*/\n\tfunction toggleClass(x){\n\t\tlet cls=x.cls||x.args[0];\n\t\tbu.checkType('string',cls);\n\t\tif(cls=='undefined'){\n\t\t\tthis._log.throw(\"toggleClass() was called with the string 'undefined', probably a mistake.\",x);\n\t\t}\n\n\t\t//Determine if we're adding or removing class\t\n\t\tlet c=test2.call(this,x);\n\n\t\tif(c.test){\n\t\t\tif(x.node.classList.contains(cls)){\n\t\t\t\tthis._log.trace(`Node already has class '${cls}'.`,x.node);\n\t\t\t}else{\n\t\t\t\tthis._log.trace(`Adding class '${cls}' to node:`,x.node);\n\t\t\t\tx.node.classList.add(cls);\n\t\t\t}\n\t\t}else{\n\t\t\tif(x.node.classList.contains(cls)){\n\t\t\t\tthis._log.trace(`Removing class '${cls}' from node:`,x.node);\n\t\t\t\tx.node.classList.remove(cls);\n\t\t\t}else{\n\t\t\t\tthis._log.trace(`Node correctly doesn't have class '${cls}'.`,x.node);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\n\t/*\n\t* Set a prop directly on the node to the underlying value. \n\t*\n\t* @param object \tx  \t\t\t\tAn object containing the following:\n\t*   @prop elem \t\t node \t\t\t  The node to operate on\n\t*   @prop any\t \t value \t\t\t  The new value of the prop on the xxx instance. Used as the elemts prop value value,\n\t* \t@prop string \t args|arg|prop \t  The prop to set\n\t*\n\t* @return void\n\t*\n\t* @call(xxx instance) \tfor logging purposes\n\t*/\n\tfunction followProp(x){\n\t\tlet prop=x.prop||x.args[0];\n\t\tbu.checkType('string',prop);\n\t\tthis._log.trace(`Setting prop '${prop}' = ${x.value}`,x.node);\n\t\tx.node[prop]=x.value\n\t\treturn;\n\t}\n\n\n\t/*\n\t* Set a prop directly on the node if the underlying value passes a test. The prop is set to $value or optional $trueValue/$falseValue\n\t*\n\t* @param object \tx  \t\t\t\tAn object containing the following:\n\t*   @prop elem \t\t node \t\t\t  The node to operate on\n\t*   @prop any\t \t value \t\t\t  The new value of the prop on the xxx instance. Used to test if we're setting the prop\n\t* \t@prop array \t   args\n\t*\t  @arg string \t\t propName\t\tThe prop to set\n\t*\t  @arg @opt any \t trueValue \t\tDefaults to $value. The value to set if the test returns truthy\n\t*\t  @arg @opt any \t falseValue \tIf omitted, the value of the prop will not be touched if test fails (which enables you to\n\t*\t\t\t\t\t\t\t\t\t\t  have multiple actions on the same node to create a 'case' scenario)\n\t* \t@opt array \t\t\ttest  \t\t\t@see test2()\t\t\t\t\t\t\t\t \n\t*\n\t*\n\t* @return void\n\t*\n\t* @call(xxx instance) \tfor logging purposes\n\t*/\n\tfunction toggleProp(x){\n\t\tlet prop=x.args[0]\n\t\t\t,trueValue=x.args.length>1 ? x.args[1] : x.value\n\t\t\t,falseValue=x.args[2] //defaults to undefined\n\t\t \t,c=test2.call(this,x)\n\t\t\t,v=c.test ? trueValue : falseValue\n\t\t;\n\t\tthis._log.trace(`Setting prop '${prop}' = ${v}`,x.node,c.logstr);\n\t\tx.node[prop]=v; \n\t\treturn;\n\t}\n\n\n\t/*\n\t* Set an attribute to the underlying $value, or to $trueValue if $value passes a test\n\t*\n\t* @param object \t\tx  \t\t\t\tAn object containing the following:\n\t*   @prop elem \t\t\t node \t\t\t  The node to operate on\n\t*   @prop any \t\t \t value \t\t\t  The new value of the prop on the xxx instance. Used as the attribute value and to test\n\t*\t\t\t\t\t\t\t\t\t\t\tif the attribute should be removed.\n\t* \t@prop array \t   args\n\t*\t  @arg string \t\tattrName\t\tThe attribute to set\n\t*\t  @opt string \t\ttrueValue \t\tDefaults to $value. The value to set if the test returns truthy.\n\t* \t@opt array \t\t\t test  \t\t\t  @see test2(). A falsey test removes the \n\t*\t\t\t\t\t\t\t\t    \t\tattribute entirely from the element.\n\t* @return void\n\t*\n\t* @call(xxx instance) \tfor logging purposes\n\t*/\n\tfunction setAttribute(x){\n\t\tbu.checkTypes(['string',['string','undefined']],x.args);\n\t\tlet attrName=x.args[0]\n\t\t\t,trueValue=x.args.length==2 ? x.args[1] : x.value\n\t\t\t,c=test2.call(this,x)\n\t\t;\n\t\tif(c.test){\n\t\t\tthis._log.trace(`Setting attr '${attrName}'='${trueValue}' on node:`,x.node,c.logstr);\n\t\t\tx.node.setAttribute(attrName,trueValue); \n\t\t}else{\n\t\t\tthis._log.trace(`Removing attr '${attrName}' from node:`,x.node,c.logstr);\n\t\t\tx.node.removeAttribute(attrName); \n\t\t}\n\t\treturn;\n\t}\n\n\n\t/*\n\t* Set text at begining of node without affecting child nodes, optionaly formatting it first\n\t*\n\t* @param object x \t\t\n\t*  @prop node \n\t*  @prop string|number value\n\t*  @opt string|function format|args[0] \tA live function or a '.' delimited string used to look on\n\t*\t\t\t\t\t\t\t\t\t\t 'this' and window\n\t*\n\t* @return void\n\t* @call(xxx instance) \t//Used for logging and to look for $format functions\n\t*/\n\tfunction setText(x){\n\t\tvar format=x.format||x.args[0];\n\t\tif(format){\n\t\t\tif(typeof format=='function'){\n\t\t\t\tx.value=format(x.value);\n\t\t\t}else if(typeof format=='string'){\n\t\t\t\tlet str=bu.formatString(format,x.value);\n\t\t\t\tif(str){\n\t\t\t\t\tx.value=str\n\t\t\t\t}else{\n\t\t\t\t\ttry{\n\t\t\t\t\t\tlet address=format.split('.');\n\t\t\t\t\t\tformat=bu.nestedGet(this||window,address)||bu.nestedGet(window,address);\n\t\t\t\t\t\tx.value=format(x.value);\n\t\t\t\t\t}catch(err){\n\t\t\t\t\t\tgetLog(this).warn(\"Bad 'format' arg\",format);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tgetLog(this).makeTypeError(\"'format' arg to be function or string\",format)\n\t\t\t\t\t.changeLvl('warn').exec();\n\t\t\t}\n\t\t}\n\n\t\tbu.setFirstTextNode(x.node,x.value);\n\t\treturn;\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t/*\n\t* Prepare an xxx instance to use actions and register some basic actions. \n\t*\n\t* NOTE: This method should be called from xxx constructors\n\t* NOTE2: If you call this method, you probably also want to set registerActionHandler() on the classes prototype\n\t*\n\t* @param @opt array includeExclude \t\tArray of action names. If the first item is ! the list is of those\n\t*\t\t\t\t\t\t\t\t\t\tto ignore, else those to include\n\t*\n\t* @return void\n\t* @call(xxx instance)\n\t*/\n\tfunction setupActions(includeExclude){\n\t\t\n\t\tthis._private.actions={}\n\n\n\t\tif(Array.isArray(includeExclude)){\n\t\t\tif(includeExclude[0]=='!')\n\t\t\t\tvar exclude=includeExclude.slice(1);\n\t\t\telse\n\t\t\t\tvar include=includeExclude;\n\t\t}\n\n\t\tvar register=(name, func)=>{\n\t\t\tif((include && include.indexOf(name)==-1)||exclude && exclude.indexOf(name)>=-1)\n\t\t\t\treturn;\n\t\t\telse\n\t\t\t\tregisterActionHandler.call(this,name,func,true);\t\t\t\t\n\t\t}\n\n\t\tregister('hide',setDisplay.bind(this,false));\n\t\tregister('show',setDisplay.bind(this,true));\n\t\tregister('id',(x)=>x.node.id=x.value);\n\t\tregister('class',followClass.bind(this));\n\t\tregister('classif',toggleClass.bind(this));\n\t\tregister('prop',followProp.bind(this)); \n\t\tregister('propif',toggleProp.bind(this)); \n\t\tregister('attr',setAttribute.bind(this));\n\t\tregister('value',(x)=>{bu.setValueOnElem(x.node,x.value)});   //set value or checked attribute of node (or html if not input)\n\t\tregister('html',(x)=>{x.node.innerHTML=x.value});\t\t\t\t//set innerHTML without checking anything\n\t\tregister('text',setText.bind(this)); \t\t\t\t\t\t\t//set text at begining of node without affecting child nodes\n\t\tregister('showtext',(x)=>{ \n\t\t\tsetText(x);\n\t\t\tsetDisplay.call(this,true,x);\n\t\t});\n\t\tregister('onclick',(x)=>{\n\t\t\tif(typeof x.value=='function'){\n\t\t\t\tx.node.onclick=x.value;\n\t\t\t}else{\n\t\t\t\tlet address=x.value.split('.');\n\t\t\t\tlet func=address.length==1 ? this[x.value] : bu.nestedGet(this,address);\n\t\t\t\tif(func && typeof func=='function'){\n\t\t\t\t\tx.node.onclick=func;\n\t\t\t\t}else{\n\t\t\t\t\tx.node.setAttribute('onclick',x.value);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t}\n\n\t/*\n\t* Add new actions/capabilities to xxx instance.\n\t*\n\t* @param string name \t\tString name of action. Will be converted to lower case and can then be invoked by attributes, eg: xxx-bind-nameoffunction\n\t* @param function func \t\tWill be called with: (this,{node, key, value, args:[],...any other props set on ^attr)\n\t*\n\t* @throws TypeError\n\t*\n\t* @return void\n\t*\n\t* @call(xxx instance) \t\tSet on proto.prototype^\n\t*/\n\tfunction registerActionHandler(name, func, silent=false){\n\n\t\tbu.checkTypes(['string','function'],[name,func]);\n\t\tname=name.toLowerCase();\n\t\tvar a=this._private.actions\n\t\tif(a.hasOwnProperty(name)){\n\t\t\ta[name].push(func);\n\t\t\tif(!silent) this._log.debug(`Chained function to action '${name}'. Total funcs: ${a[name].length}`);\n\t\t}else{\n\t\t\ta[name]=[func];\n\t\t\tif(!silent) this._log.debug(`Registered action '${name}'.`);\n\t\t}\n\n\t\treturn;\n\t}\n\n\n\n\n\t/*\n\t* Compare a value to another value. (this method is usually called from executeAction)\n\t*\n\t* @param object \tx\t\t\tThe object passed to the action function \n\t*   @prop any \t\t value \t\t  The value to check. If this is the only arg passed then @see bu.isEmpty($value,'*')\n\t*   @prop array \t test\t\n\t* \t  @arg string \t  operator \t    @see bu.compare(), the operator used to compare $value to $compareTo\n\t* \t  @arg prim \t  compareTo \t@see bu.compare()\n\t* \t  @opt prim \t  endOfRange \t@see bu.compare(). Only comes into play if $operator=='between'\n\t*\n\t* @return Object \t\t\t\t{test:bool, logstr:string} \t\n\t* @call(<xxx>)\n\t*/\n\tfunction test1(x){\n\t\tvar obj={test:bu.compare(x.value,x.test[0],x.test[1],x.test[2])};\n\t\t\tif(this._log.options.lowestLvl<3){\n\t\t\t\tobj.logstr=(obj.test ? '<not> ':'')+bu.logVar(x.value)+x.test[0]+bu.logVar(x.test[1])\n\t\t\t\t+(x.test[2]==undefined ? '' : ` ${String(x.test[2])}`)//will only be the case on 'between'\n\t\t}\n\t\treturn obj;\n\t}\n\n\n\t/*\n\t* Check if a test has already been performed, or if the underlying value is empty\n\t*\n\t* @prop object \tx \tThe object passed to the action function, which may or may not have the prop .test already set\n\t*\n\t* @return Object \t\t\t\t{test:bool, logstr:string} \t\n\t* @call(<xxx>)\n\t*/\n\tfunction test2(x){\n\t\tif(x && x.test && x.test.hasOwnProperty('test'))\n\t\t\treturn x.test;\n\t\telse{\n\t\t\tvar obj={test:!bu.isEmpty(x.value,'*')} //'*'=> zero, null and false are considered empty\n\t\t\tif(this._log.options.lowestLvl<3){\n\t\t\t\tobj.logstr=bu.logVar(x.value)\n\t\t\t\tobj.logstr=(obj.test ? '<not empty> ' : '<empty> ')+obj.logstr\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\t}\n\n\n\t/*\n\t* Apply a pattern to a value. This can be used to combine different pieces of information.\n\t*\n\t* @param string|number key \t\tThe Repeater index or the Binder key. Type is not checked but may be converted to primitive.\n\t* @param any value \t\t\t\tThe value of the Repeater/Binder at that $key\n\t* @param string pattern \t\tA pattern like \"#-${me.age}${foo}banan#hat\"\n\t* @opt any node \t\t\t\tINCLUDED AS LAST ITEM TO LOG FOR EASY DEBUGGING, USED FOR NOTHING ELSE\n\t*\n\t* @throw <ble TypeError> \t\tIf $pattern isn't a string \n\t* @throw <ble EMISMATCH> \t\tIf $pattern contains ${foo} when value is not complex\n\t*\n\t* @return any|primitive \t\tIf $pattern == '$' or '#' than anything can be returned, else a primitive is guaranteed\n\t*/\n\tfunction applyPattern(key,value,pattern,node=undefined){\n\n\t\tvar log=getLog(this);\n\n\t\t//Start with 2 situations where any value can be returned, including undefined\n\t\tif(pattern=='$'){\n\t\t\tlog.trace(\"Pattern '$', using original value:\",value,node);\n\t\t\treturn value;\n\t\t}\n\t\tif(pattern=='#'){\n\t\t\tlog.trace(\"Pattern '#', using key only:\",key,node);\n\t\t\treturn key;\n\t\t}\n\n\t\t//Ok, from this point on we WILL be returning a primitive. If we wanted a live sub-object passed to a function, \n\t\t//then I'm afraid that function will just have to use '$' and find the prop itself\n\n\n\t\tdep.bu.checkType('string',pattern);\n\t\tlet onComplexPattern=(value===undefined||value===null?'empty':typeof value=='object'?'':'throw');\n\n\t\t//Let's say we have\n\t\t//\tkey=7 \t\tvalue={foo:\"bar\",me:{age:4}}\t\tpattern=\"#-${me.age}${foo}banan#hat\"\n\t\t//First we split the pattern into components, \n\t\t//\t[\"#\", \"-\", \"${me.age}\", \"${foo}\", \"banan\", \"#\", \"hat\"]\n\t\t//then we substitute each item, \n\t\t//\t[7, \"-\", 4, \"bar\", \"banan\", 7, \"hat\"]\n\t\t//and finally we combine them into a string\n\t\t//\t\"7-4barbanan7hat\"\n\t\tvar string=pattern.split(/(\\$\\{[^}]+\\}|#|\\$)/)\n\t\t\t.filter(part=>part) //remove any empty parts that may have formed\n\t\t\t.map(part=>{\n\t\t\t\tif(part=='$')\n\t\t\t\t\treturn value; //WARN: this may include unexpected stuff into the resulting string, but a custom toString()\n\t\t\t\t\t\t\t\t  //\t  method will sort that...\n\t\t\t\tif(part=='#')\n\t\t\t\t\treturn key;\n\n\t\t\t\tlet m=part.match(/\\$\\{([^}]+)\\}/);\n\t\t\t\tif(m){\n\t\t\t\t\tif(onComplexPattern=='empty'){\n\t\t\t\t\t\treturn '';\n\t\t\t\t\t}else if(onComplexPattern=='throw'){\n\t\t\t\t\t\tlog.makeError(\"Got complex pattern but primitive value.\",{pattern,part,value})\n\t\t\t\t\t\t\t.setCode('EMISMATCH').throw();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tlet val=m[1].contains('.') ? dep.bu.nestedGet(value,m[1].split('.')) : value[m[1]]\n\t\t\t\t\t//\"undefined\" is never going to be what we want in the middle of a string, so warn an use an empty one\n\t\t\t\t\treturn ((val=='undefined'||val==undefined)? '' : val)\n\t\t\t\t}\n\n\t\t\t\t//If we're still running then this is not a dynamic part, just return it\n\t\t\t\treturn part;\n\t\t\t}).join('')\n\t\t;\n\n\t\t//Now we have a string, but perhaps it's a representation of a primitive, eg. \"false\" which we want to\n\t\t//to be able to evaluate falsey\n\t\tvar resolved=dep.bu.stringToPrimitive(string)\n\n\t\t//Finally we want to log something. Since this method is also used to test which template should be used by\n\t\t//Repeater we can't well warn every time it produces an empty string since that will be most of the time, so\n\t\t//we've included a hidden 4th argument...\n\t\tif(resolved==='' && arguments[3]!='noWarn'){\n\t\t\tlog.warn(`Resolved pattern to empty string:`,{pattern,value,key},node);\n\t\t}else{\n\t\t\tlog.trace(`Resolved pattern '${pattern}':`,[value, '=>',resolved],node);\n\t\t}\n\n\t\t//Now we want to log something\n\t\treturn resolved;\n\t}\n\n\n\n\n\t/*\n\t* Apply an instruction to a node. \n\t*\n\t* @param <HTMLElement> node\n\t* @param object inst \t\t\tThe instructions stored on the node relevant to $event\n\t* @param object event \t \t\tThe data emitted by the underlying smarty \n\t*\n\t* NOTE:   An action can consist of 1 or more callbacks\n\t* NOTE 2: Callbacks will be called in the order they where registered\n\t* NOTE 3: The same object is passed to each callback, ie. any edits will be seen by the next one\n\t* NOTE 4: Throwing an error will prevent further callbacks. Throw the string 'abort' to exit without\n\t*         logging an error\n\t*\n\t* @return void\n\t*\n\t* @call(xxx instance) \t\t\tSet on proto.prototype^\n\t* @no_throw\n\t*/\n\tfunction executeAction(node, inst, event){\n\t\ttry{\n\t\t\tif(this._private.actions.hasOwnProperty(inst.fn)){\n\t\t\t\t//The action gets called with a single object that contains the event, node \n\t\t\t\t//and instruction, which is also de-linked from the passed in objects\n\t\t\t\tvar x=Object.assign({},inst,{node},event);\n\t\t\t\t\t//^ NOTE: The event takes presidence, so if you have args with same name they will get lost\n\t\t\t\t\t//^ NOTE2: This live object gets passed to each chained func, so it can be altered...\n\t\t\t\t\n\t\t\t\t//If a pattern was given, apply it now to both new and old value\n\t\t\t\tif(x.pattern){\n\t\t\t\t\tx.value=applyPattern.call(this,x.key,x.value,x.pattern); //throws on bad pattern\n\t\t\t\t\tif(x.old!=undefined){\n\t\t\t\t\t\tx.old=applyPattern.call(this,x.key, x.old, x.pattern);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//If testing was called for, do so now, replacing the test array with an object\n\t\t\t\tif(x.test){\n\t\t \t\t\tx.test=test1.call(this,x);\n\t\t\t\t}\n\n\t\t\t\t//Check if we're calling one or more functions. \n\t\t\t\tvar funcs=this._private.actions[inst.fn], msg=`Executing fn '${inst.fn}'`\n\t\t\t\tif(funcs.length>1){\n\t\t\t\t\tthis._log.debug(`${msg} (${funcs.length} funcs):`,{funcs:funcs.map(f=>f.name),arg:x});\n\t\t\t\t\tfuncs.forEach(f=>f.call(this,x)) \n\t\t\t\t\t\t//^end the chain early by throwing. throw the string 'abort' to end without logging error\n\t\t\t\t}else{\n\t\t\t\t\tthis._log.trace(`${msg}:`,x);\n\t\t\t\t\tfuncs[0].call(this,x);\n\t\t\t\t}\n\n\t\t\t}else{\n\t\t\t\tthrow `No handler for action '${String(inst.fn)}'`;\n\t\t\t}\n\t\t}catch(err){\n\t\t\t//Allow a way for action funcs to stop further processing without logging error\n\t\t\tif(err==='abort'){\n\t\t\t\tthis._log.trace(`Aborted '${inst.fn}'`);\n\t\t\t}else{\n\t\t\t\tthis._log.error('Failed to execute action.',err,node,inst)\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\n\n\n\n\n\n\n\t/*\n\t* Check that a targetClass is not already in use, then register it on the appropriate\n\t* constructor's _instances Map\n\t*\n\t* @param string targetClass\n\t*\n\t* @call(xxx instance)\n\t*/\n\tfunction addInstance(targetClass){\n\t\tconst log=getLog(this);\n\t\ttry{\n\t\t\tbu.checkType('string',targetClass);\n\t\t\tif(targetClass=='undefined')\n\t\t\t\tthrow \"The string 'undefined' is not suitable as targetClass\";\n\t\t}catch(err){\n\t\t\tlog.throw(`Bad targetClass (arg#1), cannot setup xxx.${this.constructor.name}.`,err)\n\t\t}\n\t\t//Check with all xxx types if an instance has already been registered with this class\n\t\tvar name;\n\t\tfor(name in _export){\n\t\t\tlet c=_export[name];\n\t\t\tif(c.hasOwnProperty('_instances') && c._instances.has(targetClass)){\n\t\t\t\tlog.makeError(`A xxx.${c.name} with class ${targetClass} already exists`\n\t\t\t\t\t,c._instances.get(targetClass)).setCode('EEXIST').throw();\n\t\t\t}\n\t\t}\n\t\t\n\t\t//If still running, register it\n\t\tthis.constructor._instances.set(targetClass,this);\n\t}\n\n\n\t/*\n\t* Common setup... see func body\n\t* @call(xxx instance)\n\t*/\n\tfunction setupPrivateLogEvents(targetClass,options){\n\t\t//Store options and targetClass on _private\n\t\tbu.checkType('object',options); //throw on fail\n\t\tObject.defineProperty(this,'_private',{enumerable:false,value:{targetClass}});\n\t\tthis._private.options=Object.assign({},this.constructor._defaultOptions,options);\n\n\n\t\t//Setup log, using targetClass as print name as well\n\t\tObject.defineProperty(this,'_log',{enumerable:false,value:new dep.BetterLog(this,\n\t\t\tObject.assign({'name':targetClass},options))});\n\t\t\n\n\t\t//Inherit from dep.BetterEvents and set failed emits to log to our log\n\t\tdep.BetterEvents.call(this);\n\t\tObject.defineProperty(this._betterEvents,'onerror',{value:this._log.error});\n\t}\n\n\n\n\n\tvar proto={\n\t\t//NOTE: This object should be assigned to the prototype of xxx.bind and xxx.repeat. All methods in it\n\t\t//\t\twill then be callable as this.METHOD from inside each xxx instance, instead of xxx.METHOD.call(this)\n\t\tprototype:{\n\t\t\tregisterActionHandler\n\t\t\t,executeAction\n\t\t}\n\t\t,static:{\n\t\t\thideElement\n\t\t\t,showElement\n\t\t\t,setText\n\t\t\t,applyPattern\n\t\t}\n\t\t,getInstructions\n\t\t,setupActions\n\t\t,addInstance\n\t\t,setupPrivateLogEvents\n\t\t,getLog\n\t};\n\n\n\n\n\t//Now require the pieces of the framework and export them\n\t_export.Binder=proto.Binder=__webpack_require__(/*! ./xxx-bind.class.js */ \"./src/xxx-bind.class.js\")(dep,proto);\n\t_export.Navigator=__webpack_require__(/*! ./xxx-nav.class.js */ \"./src/xxx-nav.class.js\")(dep,proto);\n\t_export.Repeater=__webpack_require__(/*! ./xxx-repeat.class.js */ \"./src/xxx-repeat.class.js\")(dep,proto);\n\n\treturn _export;\n}\n\t\n//simpleSourceMap=\n//simpleSourceMap2=\n\n//# sourceURL=webpack:///./src/xxx.proto.js?");

/***/ })

/******/ });